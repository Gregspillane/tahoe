# CORRECTED: Task moved to Release 3 per masterplan validation
# CORRECTED: ID changed from r4-t03 to r3-t04 per Release 3: Advanced Orchestration
task:
  id: "r3-t04-workflow-state-checkpointing"
  name: "Build Workflow State Checkpointing and Recovery"
  description: "Implement workflow state checkpointing and recovery using ADK session services for resilient execution"
  complexity: "medium"
  estimated_hours: 4
  
  context:
    why: "Workflow checkpointing enables recovery from failures and step-by-step debugging using ADK's built-in state management"
    architectural_role: "Extends ADK session services with workflow-specific state persistence and recovery patterns"
    depends_on_tasks: ["r3-t01", "r3-t02"] # CORRECTED: Updated dependencies to Release 3 tasks
    enables_tasks: ["r3-t05-workflow-optimization"] # CORRECTED: Updated to enable other R3 tasks
    references:
      masterplan: "@MASTERPLAN.md#release-3-advanced-orchestration"
      architecture: "@memory-bank/architecture.md#workflow-engine"
      adk_docs: "https://google.github.io/adk-docs/sessions/"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/workflow_checkpoints.py"
        purpose: "Workflow checkpointing and recovery using ADK session services" # CORRECTED: Focus on checkpointing, not comprehensive state management
        exports:
          - "WorkflowCheckpointManager: ADK session-integrated checkpoint manager"
          - "CheckpointState: Workflow state data model"
          - "WorkflowRecovery: Recovery coordination service"
          - "SessionCheckpointStore: ADK session service adapter" # ADDED: Integration with ADK session services
        content_structure: |
          # VERIFIED: ADK imports match official documentation
          from typing import Dict, Any, List, Optional, Protocol
          from datetime import datetime, timedelta
          from pydantic import BaseModel, Field
          import logging
          import json
          from abc import ABC, abstractmethod
          import asyncio
          
          # VERIFIED: ADK session imports per official docs
          from google.adk.sessions import InMemorySessionService, Session
          from google.adk.runners import InMemoryRunner
          from google.adk.events import Event
          
          logger = logging.getLogger(__name__)
          
          class CheckpointState(BaseModel): # CORRECTED: Renamed from WorkflowStateSnapshot
              """Workflow state data for checkpointing"""
              workflow_id: str
              timestamp: datetime
              step_id: Optional[str]
              session_state: Dict[str, Any] # ADDED: Aligns with ADK session state
              workflow_context: Dict[str, Any] # CORRECTED: Renamed from context
              step_outputs: Dict[str, Any] # CORRECTED: Renamed from outputs
              checkpoint_metadata: Dict[str, Any] = Field(default_factory=dict)
          
          class WorkflowCheckpoint(BaseModel): # CORRECTED: Renamed from Checkpoint
              """Workflow checkpoint using ADK session integration"""
              checkpoint_id: str
              workflow_id: str
              session_id: str # ADDED: ADK session integration
              created_at: datetime
              step_id: str
              checkpoint_state: CheckpointState # CORRECTED: Updated reference
              can_resume: bool = True
              expires_at: Optional[datetime] = None
          
          class SessionCheckpointStore: # ADDED: ADK session service adapter
              """Adapter for storing checkpoints in ADK session services"""
              
              def __init__(self, session_service: Optional[Any] = None):
                  # VERIFIED: ADK pattern for session service usage
                  self.session_service = session_service or InMemorySessionService()
                  self.checkpoint_prefix = "checkpoint:"
              
              async def save_checkpoint(
                  self,
                  session_id: str,
                  checkpoint: WorkflowCheckpoint
              ) -> bool:
                  """Save checkpoint using ADK session state"""
                  try:
                      # VERIFIED: ADK state management pattern
                      session = await self.session_service.get_session(session_id)
                      if session:
                          # Store checkpoint in session state with prefix
                          checkpoint_key = f"{self.checkpoint_prefix}{checkpoint.checkpoint_id}"
                          session.state[checkpoint_key] = checkpoint.model_dump()
                          return True
                      return False
                  except Exception as e:
                      logger.error(f"Failed to save checkpoint: {e}")
                      return False
              
              async def load_checkpoint(
                  self,
                  session_id: str,
                  checkpoint_id: str
              ) -> Optional[WorkflowCheckpoint]:
                  """Load checkpoint from ADK session state"""
                  try:
                      session = await self.session_service.get_session(session_id)
                      if session:
                          checkpoint_key = f"{self.checkpoint_prefix}{checkpoint_id}"
                          checkpoint_data = session.state.get(checkpoint_key)
                          if checkpoint_data:
                              return WorkflowCheckpoint(**checkpoint_data)
                      return None
                  except Exception as e:
                      logger.error(f"Failed to load checkpoint: {e}")
                      return None
          
          class WorkflowCheckpointManager: # CORRECTED: Main checkpoint manager class
              """ADK session-integrated checkpoint manager for workflows"""
              
              def __init__(self, session_service: Optional[Any] = None):
                  # VERIFIED: ADK session service integration pattern
                  self.checkpoint_store = SessionCheckpointStore(session_service)
                  self.active_checkpoints: Dict[str, List[WorkflowCheckpoint]] = {}
              
              async def create_checkpoint(
                  self,
                  workflow_id: str,
                  session_id: str,
                  step_id: str,
                  session_state: Dict[str, Any],
                  workflow_context: Dict[str, Any],
                  step_outputs: Dict[str, Any],
                  ttl_hours: int = 24
              ) -> WorkflowCheckpoint:
                  """Create workflow checkpoint in ADK session"""
                  from uuid import uuid4
                  
                  checkpoint_id = f"wf_cp_{uuid4().hex[:12]}"
                  
                  checkpoint_state = CheckpointState(
                      workflow_id=workflow_id,
                      timestamp=datetime.now(),
                      step_id=step_id,
                      session_state=session_state,
                      workflow_context=workflow_context,
                      step_outputs=step_outputs
                  )
                  
                  checkpoint = WorkflowCheckpoint(
                      checkpoint_id=checkpoint_id,
                      workflow_id=workflow_id,
                      session_id=session_id,
                      created_at=datetime.now(),
                      step_id=step_id,
                      checkpoint_state=checkpoint_state,
                      expires_at=datetime.now() + timedelta(hours=ttl_hours)
                  )
                  
                  # Save using ADK session services
                  success = await self.checkpoint_store.save_checkpoint(session_id, checkpoint)
                  if success:
                      # Track active checkpoints
                      if workflow_id not in self.active_checkpoints:
                          self.active_checkpoints[workflow_id] = []
                      self.active_checkpoints[workflow_id].append(checkpoint)
                      
                      logger.info(f"Created workflow checkpoint {checkpoint_id} for workflow {workflow_id}")
                  
                  return checkpoint
          
              async def restore_from_checkpoint(
                  self,
                  session_id: str,
                  checkpoint_id: str
              ) -> Optional[CheckpointState]:
                  """Restore workflow state from checkpoint"""
                  checkpoint = await self.checkpoint_store.load_checkpoint(session_id, checkpoint_id)
                  
                  if checkpoint:
                      # Check if expired
                      if checkpoint.expires_at and checkpoint.expires_at < datetime.now():
                          logger.warning(f"Checkpoint {checkpoint_id} has expired")
                          return None
                      
                      logger.info(f"Restored workflow from checkpoint {checkpoint_id}")
                      return checkpoint.checkpoint_state
                  
                  return None
              
              async def list_workflow_checkpoints(
                  self,
                  workflow_id: str
              ) -> List[WorkflowCheckpoint]:
                  """List all checkpoints for a workflow"""
                  if workflow_id in self.active_checkpoints:
                      # Filter out expired checkpoints
                      valid_checkpoints = [
                          cp for cp in self.active_checkpoints[workflow_id]
                          if not cp.expires_at or cp.expires_at > datetime.now()
                      ]
                      return valid_checkpoints
                  return []
          
          class WorkflowRecovery: # ADDED: Recovery coordination service
              """Workflow recovery coordination using ADK session integration"""
              
              def __init__(self, checkpoint_manager: WorkflowCheckpointManager):
                  self.checkpoint_manager = checkpoint_manager
                  self.recovery_handlers: Dict[str, callable] = {}
              
              def register_recovery_handler(self, step_type: str, handler: callable):
                  """Register recovery handler for specific step types"""
                  self.recovery_handlers[step_type] = handler
              
              async def attempt_recovery(
                  self,
                  workflow_id: str,
                  session_id: str,
                  failure_step_id: str
              ) -> Optional[CheckpointState]:
                  """Attempt to recover workflow from most recent checkpoint"""
                  checkpoints = await self.checkpoint_manager.list_workflow_checkpoints(workflow_id)
                  
                  if not checkpoints:
                      logger.warning(f"No checkpoints found for workflow {workflow_id}")
                      return None
                  
                  # Find most recent valid checkpoint before failure
                  valid_checkpoints = [
                      cp for cp in sorted(checkpoints, key=lambda x: x.created_at, reverse=True)
                      if cp.step_id != failure_step_id
                  ]
                  
                  if valid_checkpoints:
                      latest_checkpoint = valid_checkpoints[0]
                      recovery_state = await self.checkpoint_manager.restore_from_checkpoint(
                          session_id, latest_checkpoint.checkpoint_id
                      )
                      
                      if recovery_state:
                          logger.info(f"Successfully recovered workflow {workflow_id} from step {latest_checkpoint.step_id}")
                          return recovery_state
                  
                  logger.error(f"Failed to recover workflow {workflow_id}")
                  return None
          
              async def cleanup_expired_checkpoints(self):
                  """Clean up expired checkpoints from ADK sessions"""
                  now = datetime.now()
                  for workflow_id, checkpoints in list(self.active_checkpoints.items()):
                      valid_checkpoints = []
                      for cp in checkpoints:
                          if cp.expires_at and cp.expires_at < now:
                              # Remove from session state
                              try:
                                  session = await self.checkpoint_store.session_service.get_session(cp.session_id)
                                  if session:
                                      checkpoint_key = f"{self.checkpoint_store.checkpoint_prefix}{cp.checkpoint_id}"
                                      if checkpoint_key in session.state:
                                          del session.state[checkpoint_key]
                                  logger.info(f"Cleaned up expired checkpoint {cp.checkpoint_id}")
                              except Exception as e:
                                  logger.error(f"Error cleaning checkpoint {cp.checkpoint_id}: {e}")
                          else:
                              valid_checkpoints.append(cp)
                      
                      if valid_checkpoints:
                          self.active_checkpoints[workflow_id] = valid_checkpoints
                      else:
                          del self.active_checkpoints[workflow_id]
      
      - path: "services/agent-engine/tests/test_workflow_checkpoints.py" # CORRECTED: Updated test file name
        purpose: "Tests for workflow checkpointing and recovery with ADK integration"
        test_categories:
          - "ADK session checkpoint storage" # CORRECTED: Focus on ADK integration
          - "Checkpoint creation and restoration"
          - "Recovery coordination"
          - "Session state integration" # ADDED: ADK session testing
          - "Expired checkpoint cleanup"
    
    uses_from_previous: # CORRECTED: Updated dependencies for Release 3
      - source: "r3-t01-workflow-foundation"
        component: "WorkflowEngine"
        usage: "Workflow execution context integration"
      - source: "r3-t02-workflow-templates" # ADDED: Template integration
        component: "WorkflowTemplate"
        usage: "Template-based checkpoint structure"
    
  implementation_steps:
    - step: "Implement ADK session checkpoint adapter" # CORRECTED: Focus on ADK integration
      implementation_notes: |
        - SessionCheckpointStore using ADK session services
        - Checkpoint storage in session state with prefixes
        - Integration with InMemorySessionService and other backends
        
    - step: "Build WorkflowCheckpointManager" # CORRECTED: ADK-aligned checkpoint manager
      implementation_notes: |
        - Checkpoint creation using ADK session state
        - Restoration with session integration
        - Expiration tracking and cleanup
        
    - step: "Create WorkflowRecovery service" # ADDED: Recovery coordination
      implementation_notes: |
        - Recovery attempt coordination
        - Handler registration for step types
        - Integration with checkpoint manager
        
    - step: "Add session-aware cleanup" # CORRECTED: ADK session cleanup
      implementation_notes: |
        - Expired checkpoint removal from sessions
        - Session state cleanup integration
        - Background cleanup tasks
        
  validation:
    commands:
      - description: "Test workflow checkpointing" # CORRECTED: Focus on checkpointing
        command: "cd services/agent-engine && pytest tests/test_workflow_checkpoints.py -v"
        expected: "All ADK session integration tests pass"
      - description: "Test ADK session integration" # ADDED: ADK-specific testing
        command: "cd services/agent-engine && pytest tests/test_workflow_checkpoints.py::test_adk_session_checkpoint_storage -v"
        expected: "Session checkpoint storage works correctly"
        
    success_criteria:
      - "ADK session checkpoint storage functional" # CORRECTED: ADK-focused criteria
      - "Workflow recovery operational" # CORRECTED: Focus on recovery
      - "Session state integration working" # ADDED: ADK session integration
      - "All tests pass with ADK compliance" # CORRECTED: ADK compliance focus
      
  dependencies:
    required_before: # CORRECTED: Updated to Release 3 dependencies
      - task: "r3-t01-workflow-foundation"
        reason: "Need workflow engine with ADK integration"
      - task: "r3-t02-workflow-templates" # ADDED: Template dependency
        reason: "Need workflow templates for checkpoint structure"