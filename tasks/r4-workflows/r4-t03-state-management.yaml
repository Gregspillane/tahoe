task:
  id: "r4-t03-state-management"
  name: "Implement Workflow State Management"
  description: "Create comprehensive state management system for workflow execution with checkpointing and recovery"
  complexity: "medium"
  estimated_hours: 3
  
  context:
    why: "State management enables workflow persistence, recovery from failures, and debugging capabilities"
    architectural_role: "Provides durability and observability for workflow execution"
    depends_on_tasks: ["r4-t01"]
    enables_tasks: ["r4-t05"]
    references:
      masterplan: "@MASTERPLAN.md#workflow-engine"
      architecture: "@memory-bank/architecture.md#state-management"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/workflow_state.py"
        purpose: "Advanced workflow state management"
        exports:
          - "StateManager: Main state management class"
          - "StateStore: State persistence interface"
          - "MemoryStateStore: In-memory state store"
          - "RedisStateStore: Redis-backed state store"
          - "CheckpointManager: Checkpoint creation and recovery"
        content_structure: |
          from typing import Dict, Any, List, Optional, Protocol
          from datetime import datetime, timedelta
          from pydantic import BaseModel, Field
          import logging
          import json
          import pickle
          from abc import ABC, abstractmethod
          import asyncio
          
          import redis.asyncio as redis
          
          logger = logging.getLogger(__name__)
          
          class WorkflowStateSnapshot(BaseModel):
              """Snapshot of workflow state at a point in time"""
              workflow_id: str
              timestamp: datetime
              step_id: Optional[str]
              state_data: Dict[str, Any]
              context: Dict[str, Any]
              outputs: Dict[str, Any]
              metadata: Dict[str, Any] = Field(default_factory=dict)
          
          class Checkpoint(BaseModel):
              """Workflow checkpoint for recovery"""
              id: str
              workflow_id: str
              created_at: datetime
              step_id: str
              state_snapshot: WorkflowStateSnapshot
              can_resume: bool = True
              expires_at: Optional[datetime] = None
          
          class StateStore(ABC):
              """Abstract interface for state persistence"""
              
              @abstractmethod
              async def save_state(
                  self,
                  workflow_id: str,
                  state: Dict[str, Any]
              ) -> bool:
                  """Save workflow state"""
                  pass
              
              @abstractmethod
              async def load_state(
                  self,
                  workflow_id: str
              ) -> Optional[Dict[str, Any]]:
                  """Load workflow state"""
                  pass
              
              @abstractmethod
              async def delete_state(
                  self,
                  workflow_id: str
              ) -> bool:
                  """Delete workflow state"""
                  pass
              
              @abstractmethod
              async def list_states(
                  self,
                  filter_criteria: Optional[Dict] = None
              ) -> List[str]:
                  """List workflow states"""
                  pass
          
          class MemoryStateStore(StateStore):
              """In-memory state store for development/testing"""
              
              def __init__(self):
                  self.states: Dict[str, Dict[str, Any]] = {}
                  self.lock = asyncio.Lock()
              
              async def save_state(
                  self,
                  workflow_id: str,
                  state: Dict[str, Any]
              ) -> bool:
                  """Save state in memory"""
                  async with self.lock:
                      self.states[workflow_id] = {
                          **state,
                          "last_updated": datetime.now().isoformat()
                      }
                      return True
              
              async def load_state(
                  self,
                  workflow_id: str
              ) -> Optional[Dict[str, Any]]:
                  """Load state from memory"""
                  async with self.lock:
                      return self.states.get(workflow_id)
              
              async def delete_state(
                  self,
                  workflow_id: str
              ) -> bool:
                  """Delete state from memory"""
                  async with self.lock:
                      if workflow_id in self.states:
                          del self.states[workflow_id]
                          return True
                      return False
              
              async def list_states(
                  self,
                  filter_criteria: Optional[Dict] = None
              ) -> List[str]:
                  """List all state keys"""
                  async with self.lock:
                      return list(self.states.keys())
          
          class RedisStateStore(StateStore):
              """Redis-backed state store for production"""
              
              def __init__(
                  self,
                  redis_client: redis.Redis,
                  prefix: str = "workflow:state:",
                  ttl: int = 86400  # 24 hours default TTL
              ):
                  self.redis = redis_client
                  self.prefix = prefix
                  self.ttl = ttl
              
              def _get_key(self, workflow_id: str) -> str:
                  """Get Redis key for workflow"""
                  return f"{self.prefix}{workflow_id}"
              
              async def save_state(
                  self,
                  workflow_id: str,
                  state: Dict[str, Any]
              ) -> bool:
                  """Save state to Redis"""
                  try:
                      key = self._get_key(workflow_id)
                      state_json = json.dumps(state, default=str)
                      await self.redis.setex(key, self.ttl, state_json)
                      return True
                  except Exception as e:
                      logger.error(f"Failed to save state to Redis: {e}")
                      return False
              
              async def load_state(
                  self,
                  workflow_id: str
              ) -> Optional[Dict[str, Any]]:
                  """Load state from Redis"""
                  try:
                      key = self._get_key(workflow_id)
                      state_json = await self.redis.get(key)
                      if state_json:
                          return json.loads(state_json)
                      return None
                  except Exception as e:
                      logger.error(f"Failed to load state from Redis: {e}")
                      return None
              
              async def delete_state(
                  self,
                  workflow_id: str
              ) -> bool:
                  """Delete state from Redis"""
                  try:
                      key = self._get_key(workflow_id)
                      result = await self.redis.delete(key)
                      return result > 0
                  except Exception as e:
                      logger.error(f"Failed to delete state from Redis: {e}")
                      return False
              
              async def list_states(
                  self,
                  filter_criteria: Optional[Dict] = None
              ) -> List[str]:
                  """List workflow states in Redis"""
                  try:
                      pattern = f"{self.prefix}*"
                      keys = []
                      async for key in self.redis.scan_iter(match=pattern):
                          workflow_id = key.decode().replace(self.prefix, "")
                          keys.append(workflow_id)
                      return keys
                  except Exception as e:
                      logger.error(f"Failed to list states from Redis: {e}")
                      return []
          
          class CheckpointManager:
              """Manages workflow checkpoints for recovery"""
              
              def __init__(self, state_store: StateStore):
                  self.state_store = state_store
                  self.checkpoints: Dict[str, List[Checkpoint]] = {}
                  self.checkpoint_prefix = "checkpoint:"
              
              async def create_checkpoint(
                  self,
                  workflow_id: str,
                  step_id: str,
                  state: Dict[str, Any],
                  context: Dict[str, Any],
                  outputs: Dict[str, Any],
                  ttl_hours: int = 24
              ) -> Checkpoint:
                  """Create a new checkpoint"""
                  from uuid import uuid4
                  
                  checkpoint_id = f"cp_{uuid4().hex[:12]}"
                  
                  snapshot = WorkflowStateSnapshot(
                      workflow_id=workflow_id,
                      timestamp=datetime.now(),
                      step_id=step_id,
                      state_data=state,
                      context=context,
                      outputs=outputs
                  )
                  
                  checkpoint = Checkpoint(
                      id=checkpoint_id,
                      workflow_id=workflow_id,
                      created_at=datetime.now(),
                      step_id=step_id,
                      state_snapshot=snapshot,
                      expires_at=datetime.now() + timedelta(hours=ttl_hours)
                  )
                  
                  # Save checkpoint
                  checkpoint_key = f"{self.checkpoint_prefix}{checkpoint_id}"
                  await self.state_store.save_state(
                      checkpoint_key,
                      checkpoint.model_dump(mode='json')
                  )
                  
                  # Track checkpoint
                  if workflow_id not in self.checkpoints:
                      self.checkpoints[workflow_id] = []
                  self.checkpoints[workflow_id].append(checkpoint)
                  
                  logger.info(f"Created checkpoint {checkpoint_id} for workflow {workflow_id}")
                  return checkpoint
              
              async def restore_checkpoint(
                  self,
                  checkpoint_id: str
              ) -> Optional[Checkpoint]:
                  """Restore from checkpoint"""
                  checkpoint_key = f"{self.checkpoint_prefix}{checkpoint_id}"
                  checkpoint_data = await self.state_store.load_state(checkpoint_key)
                  
                  if checkpoint_data:
                      checkpoint = Checkpoint(**checkpoint_data)
                      
                      # Check if expired
                      if checkpoint.expires_at and checkpoint.expires_at < datetime.now():
                          logger.warning(f"Checkpoint {checkpoint_id} has expired")
                          return None
                      
                      logger.info(f"Restored checkpoint {checkpoint_id}")
                      return checkpoint
                  
                  return None
              
              async def list_checkpoints(
                  self,
                  workflow_id: str
              ) -> List[Checkpoint]:
                  """List all checkpoints for a workflow"""
                  if workflow_id in self.checkpoints:
                      # Filter out expired checkpoints
                      valid_checkpoints = [
                          cp for cp in self.checkpoints[workflow_id]
                          if not cp.expires_at or cp.expires_at > datetime.now()
                      ]
                      return valid_checkpoints
                  return []
              
              async def cleanup_expired_checkpoints(self):
                  """Remove expired checkpoints"""
                  now = datetime.now()
                  for workflow_id, checkpoints in list(self.checkpoints.items()):
                      valid_checkpoints = []
                      for cp in checkpoints:
                          if cp.expires_at and cp.expires_at < now:
                              # Delete from store
                              checkpoint_key = f"{self.checkpoint_prefix}{cp.id}"
                              await self.state_store.delete_state(checkpoint_key)
                              logger.info(f"Cleaned up expired checkpoint {cp.id}")
                          else:
                              valid_checkpoints.append(cp)
                      
                      if valid_checkpoints:
                          self.checkpoints[workflow_id] = valid_checkpoints
                      else:
                          del self.checkpoints[workflow_id]
          
          class StateManager:
              """Main state management coordinator"""
              
              def __init__(
                  self,
                  state_store: Optional[StateStore] = None,
                  enable_checkpoints: bool = True
              ):
                  self.state_store = state_store or MemoryStateStore()
                  self.checkpoint_manager = CheckpointManager(self.state_store) if enable_checkpoints else None
                  self.state_cache: Dict[str, Dict] = {}
                  self.state_listeners: List[Callable] = []
              
              async def save_workflow_state(
                  self,
                  workflow_id: str,
                  step_id: str,
                  state: Dict[str, Any],
                  create_checkpoint: bool = False
              ) -> bool:
                  """Save workflow state with optional checkpoint"""
                  try:
                      # Prepare state data
                      state_data = {
                          "workflow_id": workflow_id,
                          "step_id": step_id,
                          "state": state,
                          "timestamp": datetime.now().isoformat()
                      }
                      
                      # Save to store
                      success = await self.state_store.save_state(workflow_id, state_data)
                      
                      if success:
                          # Update cache
                          self.state_cache[workflow_id] = state_data
                          
                          # Create checkpoint if requested
                          if create_checkpoint and self.checkpoint_manager:
                              await self.checkpoint_manager.create_checkpoint(
                                  workflow_id=workflow_id,
                                  step_id=step_id,
                                  state=state,
                                  context=state.get("context", {}),
                                  outputs=state.get("outputs", {})
                              )
                          
                          # Notify listeners
                          await self._notify_state_change(workflow_id, state_data)
                      
                      return success
                      
                  except Exception as e:
                      logger.error(f"Failed to save workflow state: {e}")
                      return False
              
              async def load_workflow_state(
                  self,
                  workflow_id: str,
                  use_cache: bool = True
              ) -> Optional[Dict[str, Any]]:
                  """Load workflow state"""
                  try:
                      # Check cache first
                      if use_cache and workflow_id in self.state_cache:
                          return self.state_cache[workflow_id]
                      
                      # Load from store
                      state_data = await self.state_store.load_state(workflow_id)
                      
                      if state_data:
                          # Update cache
                          self.state_cache[workflow_id] = state_data
                      
                      return state_data
                      
                  except Exception as e:
                      logger.error(f"Failed to load workflow state: {e}")
                      return None
              
              async def recover_from_checkpoint(
                  self,
                  checkpoint_id: str
              ) -> Optional[Dict[str, Any]]:
                  """Recover workflow state from checkpoint"""
                  if not self.checkpoint_manager:
                      logger.warning("Checkpoint manager not enabled")
                      return None
                  
                  checkpoint = await self.checkpoint_manager.restore_checkpoint(checkpoint_id)
                  
                  if checkpoint:
                      # Restore state
                      state_data = {
                          "workflow_id": checkpoint.workflow_id,
                          "step_id": checkpoint.step_id,
                          "state": checkpoint.state_snapshot.state_data,
                          "context": checkpoint.state_snapshot.context,
                          "outputs": checkpoint.state_snapshot.outputs,
                          "recovered_from": checkpoint_id,
                          "recovered_at": datetime.now().isoformat()
                      }
                      
                      # Save recovered state
                      await self.save_workflow_state(
                          checkpoint.workflow_id,
                          checkpoint.step_id,
                          state_data
                      )
                      
                      return state_data
                  
                  return None
              
              def add_state_listener(self, listener: Callable):
                  """Add state change listener"""
                  self.state_listeners.append(listener)
              
              async def _notify_state_change(
                  self,
                  workflow_id: str,
                  state: Dict[str, Any]
              ):
                  """Notify listeners of state change"""
                  for listener in self.state_listeners:
                      try:
                          if asyncio.iscoroutinefunction(listener):
                              await listener(workflow_id, state)
                          else:
                              listener(workflow_id, state)
                      except Exception as e:
                          logger.error(f"State listener error: {e}")
              
              async def cleanup_old_states(self, older_than_hours: int = 24):
                  """Clean up old workflow states"""
                  cutoff_time = datetime.now() - timedelta(hours=older_than_hours)
                  
                  workflow_ids = await self.state_store.list_states()
                  for workflow_id in workflow_ids:
                      state = await self.load_workflow_state(workflow_id, use_cache=False)
                      if state:
                          timestamp_str = state.get("timestamp")
                          if timestamp_str:
                              timestamp = datetime.fromisoformat(timestamp_str)
                              if timestamp < cutoff_time:
                                  await self.state_store.delete_state(workflow_id)
                                  if workflow_id in self.state_cache:
                                      del self.state_cache[workflow_id]
                                  logger.info(f"Cleaned up old state for workflow {workflow_id}")
      
      - path: "services/agent-engine/tests/test_workflow_state.py"
        purpose: "Tests for state management"
        test_categories:
          - "State persistence"
          - "Checkpoint creation"
          - "Recovery operations"
          - "Cache management"
          - "State cleanup"
    
    uses_from_previous:
      - source: "r4-t01"
        component: "WorkflowContext"
        usage: "State structure reference"
    
  implementation_steps:
    - step: "Create StateStore interface"
      implementation_notes: |
        - Abstract interface
        - Memory implementation
        - Redis implementation
        
    - step: "Implement CheckpointManager"
      implementation_notes: |
        - Checkpoint creation
        - Checkpoint restoration
        - Expiration handling
        
    - step: "Build StateManager"
      implementation_notes: |
        - State coordination
        - Cache management
        - Listener support
        
    - step: "Add cleanup functionality"
      implementation_notes: |
        - Expired state cleanup
        - Checkpoint cleanup
        - Memory management
        
  validation:
    commands:
      - description: "Test state management"
        command: "cd services/agent-engine && pytest tests/test_workflow_state.py -v"
        expected: "All tests pass"
        
    success_criteria:
      - "State persistence working"
      - "Checkpoints functional"
      - "Recovery tested"
      - "All tests pass"
      
  dependencies:
    required_before:
      - task: "r4-t01"
        reason: "Need workflow engine base"