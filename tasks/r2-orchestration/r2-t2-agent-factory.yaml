task:
  id: "r2-t2-agent-factory"
  name: "Build Agent Factory and Base Framework"
  session_size: "Complete agent factory with database-driven instantiation and base classes"
  
  context:
    why: "Creates agents dynamically from database templates for flexible configuration"
    integrates_with: ["database-schema", "orchestration-engine", "model-registry"]
    references:
      - "masterplan agent factory (lines 688-814)"
      - "masterplan base agent interface (lines 1919-1968)"
      - "masterplan model registry (lines 816-942)"
      - "roadmap phase 2 agent infrastructure"
    
  build_spec:
    creates:
      - "services/agent-engine/src/agents/__init__.py"
      - "services/agent-engine/src/agents/factory.py"
      - "services/agent-engine/src/agents/base.py"
      - "services/agent-engine/src/models/registry.py"
      - "services/agent-engine/src/tools/registry.py"
      - "services/agent-engine/tests/test_agent_factory.py"
    modifies:
      - "src/orchestrator.py (use real factory)"
      - "requirements.txt (add google-adk)"
      - "scripts/seed.py (add tool configurations)"
    uses:
      - "Google ADK for agent framework"
      - "Database templates for configuration"
      - "Redis for template caching"
      - "ModelRegistry for model configuration"
      - "ToolRegistry for tool loading"
    
  implementation_guide:
    start_with: "Create AgentFactory class with template loading"
    core_logic:
      - "Load agent templates from database with Prisma"
      - "Cache templates in Redis (5 min TTL)"
      - "Implement ModelRegistry as configuration manager (not API integrator)"  # CORRECTED: Configuration only
      - "Implement ToolRegistry with basic load_tools method"
      - "Create ADK LlmAgent instances with proper parameters"  # VERIFIED: LlmAgent from ADK docs
      - "Use Runner and InMemorySessionService for execution"  # ADDED: Required per ADK docs
      - "Wrap in TahoeAgent for standardization"
      - "Implement _calculate_confidence with basic logic"  # ADDED: Implementation guidance
      - "Add comprehensive error handling for template loading and agent creation"  # ADDED: Error handling
      - "BaseSpecialistAgent abstract class"
      - "AgentResult dataclass for outputs"
    connects_to:
      - "Database for template storage"
      - "Redis for template caching"
      - "Model registry for LLM configuration"
      - "Tool registry for agent tools"
      - "Orchestrator for agent lifecycle"
    keeps_simple:
      - "ModelRegistry as pure configuration lookup (no API calls)"  # CORRECTED: Simplified approach
      - "Basic ToolRegistry with placeholder tools"  # CORRECTED: Basic implementation
      - "Google ADK LlmAgent integration"  # VERIFIED: Correct ADK class
      - "Simple prompt templates (format strings)"
      - "Test with mocked Prisma/Redis for reliability"  # CORRECTED: Testing approach
    
  local_validation:
    run_commands:
      - "python -m pytest tests/test_agent_factory.py -v"
      - "python scripts/test_agent_creation.py"
      - "redis-cli get 'agent:template:*'"
    verify_endpoints:
      - "Factory creates agents from templates"
      - "Templates cached in Redis"
      - "Agents have standardized interface"
    check_functionality:
      - "Can load template from database"
      - "Cache hit on second load"
      - "Agent wraps ADK LlmAgent properly"  # VERIFIED: Correct ADK class
      - "Analyze method returns AgentResult"
      - "Base class enforces interface"
      - "Error handling for missing templates works"  # ADDED: Error handling validation
      - "ModelRegistry returns proper ModelConfig"  # ADDED: ModelRegistry validation
    
  session_notes:
    context_critical:
      - "Templates drive agent behavior"
      - "TahoeAgent wraps ADK agents"
      - "Caching critical for performance"
      - "AgentResult standardizes outputs"
    remember_for_later:
      - "Factory pattern for specialist agents"
      - "Base class for all specialists"
      - "Cache key pattern for templates"
      - "Tool registry interface"

  implementation_checklist:
    - "Create AgentFactory class with ModelRegistry and ToolRegistry"
    - "Implement template loading with cache"
    - "Build create_agent method using ADK LlmAgent constructor"  # VERIFIED: ADK documentation
    - "Create TahoeAgent wrapper with all methods"
    - "Define BaseSpecialistAgent abstract class"
    - "Create AgentResult dataclass"
    - "Build ModelRegistry as configuration lookup (no API integration)"  # CORRECTED: Configuration only
    - "Build ToolRegistry with basic load_tools method"
    - "Implement _calculate_confidence with basic heuristic logic"  # ADDED: Implementation guidance
    - "Add error handling for missing templates and invalid configs"  # ADDED: Error handling
    - "Write factory tests with mocked dependencies for reliability"  # CORRECTED: Testing approach
    - "Test caching behavior"
    - "Validate ADK LlmAgent instantiation with correct parameters"  # VERIFIED: ADK documentation

  class_structure:
    AgentFactory:
      - "__init__(db, cache, model_registry, tool_registry)"
      - "load_template(id) - with caching and error handling"  # ADDED: Error handling
      - "create_agent(template) - returns TahoeAgent using ADK LlmAgent"  # VERIFIED: ADK documentation
      - "invalidate_cache(id) - clear template"
    
    TahoeAgent:
      - "adk_agent - ADK LlmAgent instance"  # VERIFIED: Correct ADK class
      - "template - configuration from DB"
      - "factory - reference to factory"
      - "analyze(input) - execute using Runner.run_async()"  # CORRECTED: Use Runner per ADK docs
      - "_build_user_prompt() - format prompt with template variables"
      - "_process_events_result(events) - extract result from ADK events"  # CORRECTED: Process events not result
      - "_calculate_confidence(result) - basic heuristic (0.85 default)"  # ADDED: Implementation detail
    
    ModelRegistry:
      - "get_config(model_name, overrides) - returns ModelConfig"
      - "_get_provider(model_name) - determine provider from name prefix"
      - "PROVIDERS - static config dict with model parameters"  # CORRECTED: Static config only
    
    ToolRegistry:
      - "load_tools(tool_names) - returns List[FunctionTool]"  # CORRECTED: Return FunctionTool instances
      - "_get_tool_function(tool_name) - returns function to wrap"
      - "Note: Wrap functions with FunctionTool(func=tool_func)"  # ADDED: ADK pattern
    
    BaseSpecialistAgent:
      - "analyze() - abstract method"
      - "get_capabilities() - abstract method"
      - "name, version - properties"
    
    AgentResult:
      - "agent_name: str"
      - "agent_version: str"
      - "score: float (0-100)"
      - "confidence: float (0-1)"
      - "findings: List[Dict]"
      - "violations: List[Dict]"
      - "recommendations: List[Dict]"
      - "execution_time: float"
      - "metadata: Dict"

  cache_patterns:
    template_cache: |
      key = f"agent:template:{template_id}"
      ttl = 300  # 5 minutes
      
      # Try cache
      cached = await redis.get(key)
      if cached:
          return json.loads(cached)
      
      # Load from DB
      template = await db.agenttemplate.find_unique(...)
      
      # Cache it
      await redis.setex(key, ttl, json.dumps(template))
      return template

  real_adk_integration:
    adk_imports: |
      # VERIFIED: Correct Google ADK imports per documentation
      from google.adk.agents import LlmAgent  # VERIFIED: Primary agent class
      from google.adk.tools import FunctionTool  # CORRECTED: Use FunctionTool not @tool
      from google.adk.runner import Runner  # ADDED: Required for agent execution
      from google.adk.sessions import InMemorySessionService  # ADDED: For session management
      # Fallback imports with try/except for development
      try:
          from google.adk.agents import LlmAgent
          from google.adk.tools import FunctionTool
          from google.adk.runner import Runner
          from google.adk.sessions import InMemorySessionService
      except ImportError:
          # Development fallback - will be replaced with real ADK
          class LlmAgent:
              def __init__(self, **kwargs): pass
          class FunctionTool:
              def __init__(self, func): pass
          class Runner:
              def __init__(self, **kwargs): pass
          class InMemorySessionService:
              def __init__(self): pass
    
    model_config: |
      from dataclasses import dataclass
      from typing import Dict, Any
      
      @dataclass
      class ModelConfig:
          model_string: str
          parameters: Dict[str, Any]
          provider: str
    
    gemini_integration: |
      # Real Gemini model configuration
      GEMINI_MODELS = {
          "gemini-2.0-flash": {
              "string": "gemini-2.0-flash",
              "default_params": {
                  "temperature": 0.3,
                  "max_tokens": 2000,
                  "top_p": 0.95
              }
          }
      }
    
    environment_requirements: |
      # Required environment variables
      GOOGLE_API_KEY=your_actual_google_api_key
      # Google ADK must be installed: pip install google-adk[full]
      
    adk_agent_instantiation: |
      # VERIFIED: ADK LlmAgent constructor parameters per documentation
      adk_agent = LlmAgent(
          name=template["name"],
          model=model_config.model_string,
          description=template.get("description", ""),
          instruction=template.get("systemPrompt", ""),  # System instructions
          tools=tools  # List of FunctionTool instances
          # Note: Model parameters handled through model string, not kwargs
      )
      
      # ADDED: ADK execution pattern with Runner
      # For agent execution in TahoeAgent.analyze():
      session_service = InMemorySessionService()
      runner = Runner(
          agent=adk_agent,
          session_service=session_service
      )
      
      # Execute with runner.run_async()
      events = []
      async for event in runner.run_async(
          user_id=trace_id,
          session_id=f"analysis_{trace_id}",
          new_message=user_prompt
      ):
          events.append(event)
      
    error_handling_patterns: |
      # Comprehensive error handling per MASTERPLAN requirements
      try:
          template = await self.load_template(template_id)
      except TemplateNotFoundError:
          raise ValueError(f"Agent template {template_id} not found")
      except Exception as e:
          logger.error(f"Failed to load template {template_id}: {str(e)}")
          raise