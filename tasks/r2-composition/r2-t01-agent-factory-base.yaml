task:
  id: "r2-t01-agent-factory-base"
  name: "Build Universal Agent Factory Base Structure"
  description: "Create the foundational agent factory system that can instantiate any ADK agent type from specifications"
  complexity: "medium"
  estimated_hours: 4
  
  context:
    why: "The agent factory is the core composition engine that creates agents dynamically from YAML/JSON specifications"
    architectural_role: "Central factory pattern that enables specification-driven agent creation without code changes"
    depends_on_tasks: ["r1-t02", "r1-t03", "r1-t05"]
    enables_tasks: ["r2-t02", "r2-t03", "r2-t04", "r2-t05"]
    references:
      masterplan: "@MASTERPLAN.md#universal-agent-factory"
      adk_docs: 
        - "https://google.github.io/adk-docs/agents/"
        - "https://google.github.io/adk-docs/agents/custom-agents/"
        - "https://google.github.io/adk-docs/sessions/session/"
      project_context: "@tasks/project-context.md#agent-composition"
      adk_patterns: "@tasks/adk-patterns.md#agent-creation"
    
  adk_components:
    imports_needed:
      # CORRECTED: Added all required ADK imports per MASTERPLAN lines 371-372, 653-657
      - "from google.adk.agents import LlmAgent, SequentialAgent, ParallelAgent, LoopAgent, BaseAgent"
      - "from google.adk.tools import FunctionTool"
      - "from google.adk.runners import InMemoryRunner"  # ADDED: For session testing
      - "from google.adk.sessions import InMemorySessionService"  # ADDED: For session management
      - "from typing import Dict, Any, Optional, List, Type"
      - "from pydantic import BaseModel, Field, validator"
      - "import yaml"
      - "import json"
      - "from pathlib import Path"
      - "from abc import ABC, abstractmethod"
      - "from datetime import datetime"  # ADDED: For timestamp tracking
      - "import logging"
    verified_patterns:
      # VERIFIED: ADK documentation confirms these patterns
      - pattern: "All ADK agents inherit from BaseAgent"
        doc_ref: "https://google.github.io/adk-docs/agents/custom-agents/"
      - pattern: "session_service is a property, not a method"
        doc_ref: "https://google.github.io/adk-docs/sessions/session/"
      - pattern: "LlmAgent uses 'name' parameter as unique identifier"
        doc_ref: "https://google.github.io/adk-docs/agents/llm-agents/"
      - pattern: "Agent specifications should define type, model, and configuration"
        doc_ref: "@MASTERPLAN.md#agent-specifications"
      - pattern: "Factory pattern for dynamic agent creation"
        doc_ref: "@MASTERPLAN.md#universal-agent-factory"
    avoid_antipatterns:
      - "Don't hardcode agent types - use dynamic dispatch"
      - "Don't create agents without validation"
      - "Don't mix specification parsing with agent creation"
      - "Don't ignore specification version compatibility"
      # ADDED: Critical ADK antipatterns from validation
      - "Don't call session_service() as a method - it's a property"
      - "Don't use hyphens in agent names - use underscores"
      - "Don't forget to handle model configuration with primary/fallbacks"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/composition.py"
        purpose: "Main agent composition module with factory classes"
        exports:
          - "UniversalAgentFactory: Main factory class"
          - "AgentBuilder: Abstract base for specific builders"
          - "AgentSpec: Pydantic model for specifications"
          - "AgentContext: Runtime context for agents"
          - "ToolRegistry: Tool registry interface stub"  # ADDED
        content_structure: |
          from google.adk.agents import LlmAgent, SequentialAgent, ParallelAgent, LoopAgent, BaseAgent
          from google.adk.tools import FunctionTool
          from typing import Dict, Any, Optional, List, Type
          from abc import ABC, abstractmethod
          from pydantic import BaseModel, Field, validator
          from datetime import datetime
          import logging
          
          logger = logging.getLogger(__name__)
          
          class AgentSpec(BaseModel):
              """Pydantic model for agent specifications"""
              api_version: str = Field(default="agent-engine/v1")
              kind: str = Field(default="AgentSpec")
              metadata: Dict[str, Any]
              spec: Dict[str, Any]
              
              @validator('api_version')
              def validate_version(cls, v):
                  if not v.startswith("agent-engine/"):
                      raise ValueError(f"Unsupported API version: {v}")
                  return v
                  
              @validator('kind')
              def validate_kind(cls, v):
                  if v != "AgentSpec":
                      raise ValueError(f"Invalid kind: {v}, expected AgentSpec")
                  return v
          
          class AgentContext(BaseModel):
              """Runtime context for agent creation"""
              user_id: Optional[str] = None
              session_id: Optional[str] = None
              environment: str = "development"
              variables: Dict[str, Any] = Field(default_factory=dict)
              parent_agent: Optional[str] = None
              
          class AgentBuilder(ABC):
              """Abstract base class for agent builders"""
              
              @abstractmethod
              def can_build(self, agent_type: str) -> bool:
                  """Check if this builder can handle the agent type"""
                  pass
                  
              @abstractmethod
              def build(self, spec: AgentSpec, context: AgentContext) -> BaseAgent:
                  """Build the agent from specification"""
                  pass
                  
              @abstractmethod
              def validate_spec(self, spec: AgentSpec) -> bool:
                  """Validate the specification for this agent type"""
                  pass
          
          # ADDED: Stub for ToolRegistry interface per MASTERPLAN lines 504-539
          class ToolRegistry:
              """Tool registry interface (stub for integration)."""
              
              def __init__(self):
                  self.tools: Dict[str, Any] = {}
              
              def get_tool(self, name: str) -> Optional[Any]:
                  """Get tool by name."""
                  return self.tools.get(name)
          
          class UniversalAgentFactory:
              """Main factory for creating agents from specifications"""
              
              def __init__(self, tool_registry: Optional[ToolRegistry] = None):
                  self.specs: Dict[str, AgentSpec] = {}
                  self.spec_loader = SpecificationLoader()
                  self.validator = SpecificationValidator()
                  # ADDED: Tool registry integration per MASTERPLAN lines 393-394, 935-936
                  self.tool_registry = tool_registry
                  
              def build_agent(self, spec_name: str, context: Optional[AgentContext] = None) -> BaseAgent:
                  """Build an agent from specification name"""
                  if context is None:
                      context = AgentContext()
                      
                  # Load specification
                  spec = self.load_spec(spec_name)
                  
                  # Validate specification
                  if not self.validator.validate(spec):
                      raise ValueError(f"Invalid specification: {spec_name}")
                  
                  # CORRECTED: Direct dispatch per MASTERPLAN lines 379-388, 921-930
                  agent_type = spec.spec.get("agent", {}).get("type", "llm")
                  
                  # Direct factory dispatch without separate builders
                  if agent_type == "llm":
                      return self._build_llm_agent(spec, context)
                  elif agent_type == "sequential":
                      return self._build_sequential_agent(spec, context)
                  elif agent_type == "parallel":
                      return self._build_parallel_agent(spec, context)
                  elif agent_type == "loop":
                      return self._build_loop_agent(spec, context)
                  elif agent_type == "custom":
                      return self._build_custom_agent(spec, context)
                  else:
                      raise ValueError(f"Unknown agent type: {agent_type}")
              
              # ADDED: Core builder methods per MASTERPLAN lines 390-416, 932-958
              def _build_llm_agent(self, spec: AgentSpec, context: AgentContext) -> LlmAgent:
                  """Build LLM agent with dynamic configuration."""
                  agent_spec = spec.spec.get("agent", {})
                  tools = self._load_tools(spec.spec.get("tools", []))
                  sub_agents = self._build_sub_agents(spec.spec.get("sub_agents", []), context)
                  
                  # Dynamic instruction building with context injection
                  instruction = self._build_instruction(
                      agent_spec.get("instruction_template", ""),
                      context
                  )
                  
                  # CORRECTED: Handle model configuration per MASTERPLAN line 401, 943
                  model_config = agent_spec.get("model", {})
                  model = model_config.get("primary", "gemini-2.0-flash") if isinstance(model_config, dict) else model_config
                  
                  return LlmAgent(
                      name=spec.metadata["name"].replace("-", "_"),  # CORRECTED: Ensure underscores
                      model=model,
                      instruction=instruction,
                      description=spec.metadata.get("description", ""),
                      tools=tools,
                      sub_agents=sub_agents,
                      **agent_spec.get("parameters", {})
                  )
              
              def _build_sequential_agent(self, spec: AgentSpec, context: AgentContext) -> SequentialAgent:
                  """Build sequential workflow agent."""
                  sub_agents = self._build_sub_agents(spec.spec.get("sub_agents", []), context)
                  return SequentialAgent(
                      name=spec.metadata["name"].replace("-", "_"),
                      sub_agents=sub_agents,
                      description=spec.metadata.get("description", "")
                  )
              
              def _build_parallel_agent(self, spec: AgentSpec, context: AgentContext) -> ParallelAgent:
                  """Build parallel workflow agent."""
                  sub_agents = self._build_sub_agents(spec.spec.get("sub_agents", []), context)
                  return ParallelAgent(
                      name=spec.metadata["name"].replace("-", "_"),
                      sub_agents=sub_agents,
                      description=spec.metadata.get("description", "")
                  )
              
              def _build_loop_agent(self, spec: AgentSpec, context: AgentContext) -> LoopAgent:
                  """Build loop workflow agent."""
                  sub_agents = self._build_sub_agents(spec.spec.get("sub_agents", []), context)
                  # Note: LoopAgent may have different constructor, adjust as needed
                  return LoopAgent(
                      name=spec.metadata["name"].replace("-", "_"),
                      sub_agents=sub_agents,
                      description=spec.metadata.get("description", "")
                  )
              
              def _build_custom_agent(self, spec: AgentSpec, context: AgentContext) -> BaseAgent:
                  """Build custom agent from specification."""
                  # Placeholder for custom agent building logic
                  raise NotImplementedError("Custom agent building to be implemented")
              
              def _build_instruction(self, template: str, context: AgentContext) -> str:
                  """Build instruction from template with context injection."""
                  if not template:
                      return ""
                  
                  # Simple variable substitution from context
                  instruction = template
                  for key, value in context.variables.items():
                      instruction = instruction.replace(f"{{{key}}}", str(value))
                  
                  return instruction
              
              def _load_tools(self, tool_specs: List[Dict]) -> List:
                  """Load tools from specifications."""
                  if not self.tool_registry:
                      return []
                  
                  tools = []
                  for tool_spec in tool_specs:
                      if tool_spec.get("source") == "registry":
                          tool = self.tool_registry.get_tool(tool_spec["name"])
                          if tool:
                              tools.append(tool)
                      # Handle inline and import sources in future
                  
                  return tools
              
              def _build_sub_agents(self, sub_agent_specs: List[Dict], context: AgentContext) -> List[BaseAgent]:
                  """Build sub-agents from specifications."""
                  sub_agents = []
                  for sub_spec in sub_agent_specs:
                      spec_ref = sub_spec.get("spec_ref")
                      if spec_ref:
                          # Recursive agent building
                          sub_agent = self.build_agent(spec_ref, context)
                          sub_agents.append(sub_agent)
                  
                  return sub_agents
                  
              def load_spec(self, spec_name: str) -> AgentSpec:
                  """Load specification by name"""
                  if spec_name in self.specs:
                      return self.specs[spec_name]
                      
                  spec_data = self.spec_loader.load(spec_name)
                  spec = AgentSpec(**spec_data)
                  self.specs[spec_name] = spec
                  return spec
                  
              def build_agent_from_dict(self, spec_dict: Dict, context: Optional[AgentContext] = None) -> BaseAgent:
                  """Build an agent directly from dictionary specification"""
                  if context is None:
                      context = AgentContext()
                      
                  spec = AgentSpec(**spec_dict)
                  
                  if not self.validator.validate(spec):
                      raise ValueError("Invalid specification dictionary")
                  
                  agent_type = spec.spec.get("agent", {}).get("type", "llm")
                  
                  # Direct dispatch
                  if agent_type == "llm":
                      return self._build_llm_agent(spec, context)
                  elif agent_type == "sequential":
                      return self._build_sequential_agent(spec, context)
                  elif agent_type == "parallel":
                      return self._build_parallel_agent(spec, context)
                  elif agent_type == "loop":
                      return self._build_loop_agent(spec, context)
                  elif agent_type == "custom":
                      return self._build_custom_agent(spec, context)
                  else:
                      raise ValueError(f"Unknown agent type: {agent_type}")
                  
              def list_supported_types(self) -> List[str]:
                  """List all supported agent types"""
                  # CORRECTED: Return hardcoded supported types
                  return ["llm", "sequential", "parallel", "loop", "custom"]
                  
              def clear_cache(self):
                  """Clear cached specifications"""
                  self.specs.clear()
                  logger.info("Cleared specification cache")
                  
      - path: "services/agent-engine/src/core/specification.py"
        purpose: "Specification loading and validation system"
        exports:
          - "SpecificationLoader: Loads specs from files"
          - "SpecificationValidator: Validates specifications"
          - "SpecificationError: Custom exception"
        content_structure: |
          from typing import Dict, Any, Optional
          from pathlib import Path
          import yaml
          import json
          import logging
          from pydantic import ValidationError
          
          logger = logging.getLogger(__name__)
          
          class SpecificationError(Exception):
              """Custom exception for specification errors"""
              pass
          
          class SpecificationLoader:
              """Loads specifications from various sources"""
              
              def __init__(self, base_path: Optional[Path] = None):
                  self.base_path = base_path or Path("services/agent-engine/specs")
                  self.cache: Dict[str, Dict] = {}
                  
              def load(self, spec_name: str) -> Dict:
                  """Load specification by name"""
                  if spec_name in self.cache:
                      return self.cache[spec_name]
                      
                  # Try different paths and formats
                  spec_data = None
                  for subdir in ["agents", "workflows", "tools"]:
                      for ext in [".yaml", ".yml", ".json"]:
                          path = self.base_path / subdir / f"{spec_name}{ext}"
                          if path.exists():
                              spec_data = self._load_file(path)
                              break
                      if spec_data:
                          break
                          
                  if not spec_data:
                      raise SpecificationError(f"Specification not found: {spec_name}")
                      
                  self.cache[spec_name] = spec_data
                  return spec_data
                  
              def load_from_path(self, path: Path) -> Dict:
                  """Load specification from specific path"""
                  if not path.exists():
                      raise SpecificationError(f"File not found: {path}")
                  return self._load_file(path)
                  
              def _load_file(self, path: Path) -> Dict:
                  """Load file based on extension"""
                  try:
                      with open(path, 'r') as f:
                          if path.suffix in ['.yaml', '.yml']:
                              return yaml.safe_load(f)
                          elif path.suffix == '.json':
                              return json.load(f)
                          else:
                              raise SpecificationError(f"Unsupported file type: {path.suffix}")
                  except Exception as e:
                      raise SpecificationError(f"Error loading {path}: {e}")
                      
              def clear_cache(self):
                  """Clear cached specifications"""
                  self.cache.clear()
                  
          class SpecificationValidator:
              """Validates agent specifications"""
              
              def __init__(self):
                  self.required_fields = {
                      "apiVersion": str,
                      "kind": str,
                      "metadata": dict,
                      "spec": dict
                  }
                  self.required_metadata = ["name", "version"]
                  self.required_spec = ["agent"]
                  self.valid_agent_types = ["llm", "sequential", "parallel", "loop", "custom"]
                  
              def validate(self, spec: Any) -> bool:
                  """Validate specification structure"""
                  try:
                      # If it's already an AgentSpec, get the dict representation
                      if hasattr(spec, 'dict'):
                          spec_dict = spec.dict()
                      else:
                          spec_dict = spec
                          
                      # Check required top-level fields
                      for field, field_type in self.required_fields.items():
                          field_name = field[0].lower() + field[1:] if field != "apiVersion" else "api_version"
                          if field_name not in spec_dict:
                              logger.error(f"Missing required field: {field_name}")
                              return False
                          if not isinstance(spec_dict[field_name], field_type):
                              logger.error(f"Invalid type for {field_name}: expected {field_type}")
                              return False
                              
                      # Check metadata
                      metadata = spec_dict.get("metadata", {})
                      for field in self.required_metadata:
                          if field not in metadata:
                              logger.error(f"Missing required metadata field: {field}")
                              return False
                              
                      # Check spec
                      spec_content = spec_dict.get("spec", {})
                      for field in self.required_spec:
                          if field not in spec_content:
                              logger.error(f"Missing required spec field: {field}")
                              return False
                              
                      # Validate agent type
                      agent_type = spec_content.get("agent", {}).get("type")
                      if agent_type not in self.valid_agent_types:
                          logger.error(f"Invalid agent type: {agent_type}")
                          return False
                      
                      # ADDED: Validate model configuration per MASTERPLAN
                      if agent_type == "llm":
                          model_config = spec_content.get("agent", {}).get("model")
                          if model_config and isinstance(model_config, dict):
                              if "primary" not in model_config:
                                  logger.error("LLM agent missing primary model")
                                  return False
                          
                      return True
                      
                  except Exception as e:
                      logger.error(f"Validation error: {e}")
                      return False
                      
              def validate_context(self, context: Dict) -> bool:
                  """Validate agent context"""
                  # Basic validation for context
                  if not isinstance(context, dict):
                      return False
                  return True
                  
      - path: "services/agent-engine/src/core/__init__.py"
        purpose: "Core module initialization"
        content: |
          from .composition import (
              UniversalAgentFactory, 
              AgentBuilder, 
              AgentSpec, 
              AgentContext,
              ToolRegistry  # ADDED: Export ToolRegistry stub
          )
          from .specification import (
              SpecificationLoader, 
              SpecificationValidator, 
              SpecificationError
          )
          
          __all__ = [
              'UniversalAgentFactory',
              'AgentBuilder', 
              'AgentSpec',
              'AgentContext',
              'ToolRegistry',  # ADDED
              'SpecificationLoader',
              'SpecificationValidator',
              'SpecificationError'
          ]
          
      - path: "services/agent-engine/tests/test_agent_factory.py"
        purpose: "Unit tests for agent factory"
        test_categories:
          - "Factory initialization"
          - "Specification loading"
          - "Agent creation from specs"
          - "Error handling"
          - "Session service property access"  # ADDED
        content_structure: |
          import pytest
          from unittest.mock import Mock, patch, MagicMock
          from pathlib import Path
          
          # CORRECTED: Import all required components
          from src.core.composition import (
              UniversalAgentFactory, 
              AgentBuilder, 
              AgentSpec, 
              AgentContext,
              ToolRegistry
          )
          from src.core.specification import (
              SpecificationLoader, 
              SpecificationValidator
          )
          # ADDED: Import ADK components for testing
          from google.adk.agents import LlmAgent, SequentialAgent, ParallelAgent
          from google.adk.runners import InMemoryRunner
          
          class TestUniversalAgentFactory:
              def test_factory_initialization(self):
                  """Test factory initializes correctly"""
                  factory = UniversalAgentFactory()
                  assert factory.specs == {}
                  assert factory.spec_loader is not None
                  assert factory.validator is not None
                  assert factory.tool_registry is None  # ADDED: Check tool registry
                  
                  # Test with tool registry
                  tool_registry = ToolRegistry()
                  factory = UniversalAgentFactory(tool_registry=tool_registry)
                  assert factory.tool_registry == tool_registry
                  
              def test_list_supported_types(self):
                  """Test listing supported agent types"""
                  factory = UniversalAgentFactory()
                  
                  types = factory.list_supported_types()
                  assert len(types) == 5
                  assert "llm" in types
                  assert "sequential" in types
                  assert "parallel" in types
                  assert "loop" in types
                  assert "custom" in types
                  
              def test_build_agent_unknown_type(self):
                  """Test error when unknown agent type"""
                  factory = UniversalAgentFactory()
                  spec_dict = {
                      "api_version": "agent-engine/v1",
                      "kind": "AgentSpec",
                      "metadata": {"name": "test", "version": "1.0.0"},
                      "spec": {"agent": {"type": "unknown"}}
                  }
                  
                  with pytest.raises(ValueError, match="Unknown agent type"):
                      factory.build_agent_from_dict(spec_dict)
              
              # ADDED: Test successful agent building
              @patch('src.core.composition.LlmAgent')
              def test_build_llm_agent(self, mock_llm_agent):
                  """Test building LLM agent from specification"""
                  factory = UniversalAgentFactory()
                  spec_dict = {
                      "api_version": "agent-engine/v1",
                      "kind": "AgentSpec",
                      "metadata": {"name": "test-agent", "version": "1.0.0"},
                      "spec": {
                          "agent": {
                              "type": "llm",
                              "model": {"primary": "gemini-2.0-flash"},
                              "instruction_template": "Test instruction"
                          }
                      }
                  }
                  
                  agent = factory.build_agent_from_dict(spec_dict)
                  mock_llm_agent.assert_called_once()
                  # Verify name has underscores, not hyphens
                  call_args = mock_llm_agent.call_args
                  assert call_args[1]['name'] == 'test_agent'
              
              # ADDED: Test session service property access
              def test_session_service_property(self):
                  """Test that session_service is accessed as property"""
                  mock_agent = Mock(spec=LlmAgent)
                  runner = InMemoryRunner(mock_agent, app_name="test")
                  
                  # CORRECTED: Access as property, not method
                  session_service = runner.session_service
                  assert session_service is not None
                      
              def test_clear_cache(self):
                  """Test clearing specification cache"""
                  factory = UniversalAgentFactory()
                  factory.specs["test"] = Mock()
                  
                  factory.clear_cache()
                  assert len(factory.specs) == 0
                  
          class TestSpecificationLoader:
              def test_loader_initialization(self):
                  """Test loader initializes correctly"""
                  loader = SpecificationLoader()
                  assert loader.base_path == Path("services/agent-engine/specs")
                  assert loader.cache == {}
                  
              def test_custom_base_path(self):
                  """Test loader with custom base path"""
                  custom_path = Path("/custom/path")
                  loader = SpecificationLoader(base_path=custom_path)
                  assert loader.base_path == custom_path
                  
              @patch('builtins.open')
              @patch('pathlib.Path.exists')
              def test_load_yaml_file(self, mock_exists, mock_open):
                  """Test loading YAML specification"""
                  mock_exists.return_value = True
                  mock_open.return_value.__enter__.return_value.read.return_value = """
                  apiVersion: agent-engine/v1
                  kind: AgentSpec
                  metadata:
                    name: test
                  spec:
                    agent:
                      type: llm
                  """
                  
                  loader = SpecificationLoader()
                  # Test will be completed in actual implementation
                  
          class TestSpecificationValidator:
              def test_validator_initialization(self):
                  """Test validator initializes correctly"""
                  validator = SpecificationValidator()
                  assert validator.required_fields is not None
                  assert "llm" in validator.valid_agent_types
                  
              def test_validate_valid_spec(self):
                  """Test validation of valid specification"""
                  validator = SpecificationValidator()
                  spec = {
                      "api_version": "agent-engine/v1",
                      "kind": "AgentSpec",
                      "metadata": {"name": "test", "version": "1.0.0"},
                      "spec": {"agent": {"type": "llm"}}
                  }
                  
                  assert validator.validate(spec) is True
                  
              def test_validate_missing_field(self):
                  """Test validation fails with missing field"""
                  validator = SpecificationValidator()
                  spec = {
                      "api_version": "agent-engine/v1",
                      "kind": "AgentSpec",
                      "metadata": {"name": "test"},  # Missing version
                      "spec": {"agent": {"type": "llm"}}
                  }
                  
                  assert validator.validate(spec) is False
                  
              def test_validate_invalid_agent_type(self):
                  """Test validation fails with invalid agent type"""
                  validator = SpecificationValidator()
                  spec = {
                      "api_version": "agent-engine/v1",
                      "kind": "AgentSpec",
                      "metadata": {"name": "test", "version": "1.0.0"},
                      "spec": {"agent": {"type": "invalid_type"}}
                  }
                  
                  assert validator.validate(spec) is False
        
    modifies: []
        
    uses_from_previous:
      - source: "r1-t03"
        component: "specification parsing system"
        usage: "Base for loading and validating agent specifications"
      - source: "r1-t05"
        component: "configuration loader"
        usage: "For loading environment-specific agent configurations"
    
  implementation_steps:
    - step: "Create core composition module structure"
      commands:
        - "mkdir -p services/agent-engine/src/core"
        - "touch services/agent-engine/src/core/__init__.py"
      validates:
        - "Directory structure exists"
        - "Python module is importable"
        
    - step: "Implement AgentSpec Pydantic model"
      implementation_notes: |
        - Define complete specification schema
        - Add validators for version compatibility
        - Include metadata validation
        - Support both YAML and JSON formats
      validates:
        - "AgentSpec model validates correctly"
        - "Version checking works"
        
    - step: "Create AgentContext model"
      implementation_notes: |
        - Define runtime context structure
        - Include session and user information
        - Support variable injection
        - Enable parent-child agent relationships
      validates:
        - "Context model handles all required fields"
        - "Variable substitution works"
        
    - step: "Implement abstract AgentBuilder"
      implementation_notes: |
        - Define builder interface
        - Include validation methods
        - Support capability checking
        - Enable builder chaining
      validates:
        - "Abstract methods defined correctly"
        - "Builder interface is complete"
        
    - step: "Build UniversalAgentFactory"
      implementation_notes: |
        # CORRECTED: Direct dispatch implementation
        - Implement direct agent type dispatch
        - Create all builder methods (_build_llm_agent, etc.)
        - Add tool loading integration
        - Add sub-agent building support
        - Add instruction template processing
        - Include model configuration handling
        - Add specification caching
        - Include comprehensive error handling
      validates:
        - "Factory can create all agent types"
        - "Factory handles model configuration"
        - "Tool loading works correctly"
        - "Sub-agent composition works"
        - "Caching works correctly"
        
    - step: "Create SpecificationLoader"
      implementation_notes: |
        - Support multiple file formats (YAML, JSON)
        - Implement path resolution
        - Add caching mechanism
        - Include error handling
      validates:
        - "Loader finds specifications correctly"
        - "YAML and JSON parsing works"
        - "Cache improves performance"
        
    - step: "Implement SpecificationValidator"
      implementation_notes: |
        - Validate required fields
        - Check agent type validity
        - Verify metadata completeness
        - Validate specification version
        # ADDED: Model configuration validation
        - Validate model configuration for LLM agents
      validates:
        - "Validator catches missing fields"
        - "Invalid types are rejected"
        - "Version compatibility checked"
        - "Model configuration validated"
        
    - step: "Write comprehensive unit tests"
      implementation_notes: |
        - Test factory initialization with/without tool registry
        - Test direct agent type dispatch
        - Test specification loading
        - Test validation logic
        - Test error conditions
        # ADDED: Critical ADK pattern tests
        - Test session_service property access
        - Test agent name underscore conversion
        - Test model configuration handling
      validates:
        - "pytest tests/test_agent_factory.py passes"
        - "Coverage > 80%"
        
    - step: "Create integration test"
      implementation_notes: |
        - Test complete flow from spec to agent
        - Verify all components work together
        - Test error propagation
        # ADDED: ADK integration tests
        - Test with actual ADK imports
        - Verify session_service property pattern
      validates:
        - "Integration test passes"
        - "End-to-end flow works"
        
  validation:
    commands:
      - description: "Run unit tests"
        command: "cd services/agent-engine && pytest tests/test_agent_factory.py -v"
        expected: "All tests pass"
        
      - description: "Check code coverage"
        command: "cd services/agent-engine && pytest tests/test_agent_factory.py --cov=src/core --cov-report=term-missing"
        expected: "Coverage > 80%"
        
      - description: "Verify imports"
        command: |
          cd services/agent-engine && python -c "
          from src.core.composition import UniversalAgentFactory, AgentBuilder, ToolRegistry
          from src.core.specification import SpecificationLoader, SpecificationValidator
          print('All imports successful')
          "
        expected: "All imports successful"
        
      - description: "Test factory initialization"
        command: |
          cd services/agent-engine && python -c "
          from src.core.composition import UniversalAgentFactory
          factory = UniversalAgentFactory()
          types = factory.list_supported_types()
          print(f'Factory supports {len(types)} agent types: {types}')
          "
        expected: "Factory supports 5 agent types: ['llm', 'sequential', 'parallel', 'loop', 'custom']"
        
    success_criteria:
      - "UniversalAgentFactory class exists and is functional"
      - "AgentBuilder abstract class defined"
      - "SpecificationLoader can load YAML and JSON"
      - "SpecificationValidator validates specifications"
      # ADDED: Critical ADK pattern validation
      - "All agent builder methods implemented"
      - "Tool registry integration works"
      - "Session service accessed as property"
      - "Agent names use underscores"
      - "Model configuration handled correctly"
      - "All unit tests pass"
      - "Code coverage > 80%"
      
  dependencies:
    required_before:
      - task: "r1-t02"
        reason: "Need ADK verified and installed"
      - task: "r1-t03"
        reason: "Need specification parsing system"
      - task: "r1-t05"
        reason: "Need configuration loading system"
        
    enables_after:
      - task: "r2-t02"
        reason: "LLM agent builder needs factory base"
      - task: "r2-t03"
        reason: "Workflow agents need factory base"
      - task: "r2-t04"
        reason: "Custom agents need factory base"
        
  notes:
    key_decisions:
      # CORRECTED: Updated to reflect direct dispatch pattern
      - "Use direct dispatch pattern instead of separate builders"
      - "Integrate tool registry from the start"
      - "Handle model configuration with primary/fallbacks"
      - "Separate specification loading from agent creation"
      - "Use Pydantic for specification validation"
      - "Support multiple specification formats"
      
    future_enhancements:
      - "Add specification versioning support"
      - "Implement specification inheritance"
      - "Complete custom agent building"
      - "Add inline and import tool sources"
      - "Create specification migration tools"
      
    technical_debt:
      - "LoopAgent constructor may need adjustment"
      - "Custom agent building placeholder needs implementation"
      - "Tool registry is currently a stub"
      - "Consider adding specification schema validation"
      - "May need to optimize caching strategy"
      - "Could benefit from async loading"