task:
  id: "r6-t01-restful-api"
  name: "Create Universal RESTful API Implementation"
  description: "Build comprehensive RESTful API for specification-driven agent orchestration, session management, workflow execution, tool registry, and model management"
  complexity: "high"  # CORRECTED: Increased from medium to reflect full scope
  estimated_hours: 12  # CORRECTED: Increased from 4 to account for complete API coverage

  context:
    why: "RESTful API provides standard HTTP interface for universal agent orchestration platform with specification-driven architecture"
    architectural_role: "External API layer for client applications with complete configuration management"
    depends_on_tasks: ["r5-t01", "r4-t01", "r3-t01", "r2-t01"]  # CORRECTED: Added r2-t01
    enables_tasks: ["r6-t03", "r7-t01"]
    references:
      masterplan: "@MASTERPLAN.md#api-architecture"
      architecture: "@memory-bank/architecture.md#api-design"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/api/routes/"
        purpose: "API route definitions"
        content:
          - "__init__.py"
          - "agents.py"  # CORRECTED: Specification-based agent composition
          - "sessions.py"
          - "workflows.py"
          - "tools.py"  # ADDED: Tool registry API
          - "models.py"  # ADDED: Model management API
          - "specs.py"  # ADDED: Configuration management API
          - "health.py"
          - "monitoring.py"  # ADDED: Observability endpoints
      
      - path: "services/agent-engine/src/api/routes/agents.py"
        purpose: "Specification-driven agent composition and management API endpoints"  # CORRECTED
        exports:
          - "router: FastAPI router for agent endpoints"
          - "compose_agent: POST /agents/compose"  # CORRECTED: Specification-based composition
          - "reconfigure_agent: PUT /agents/{id}/reconfigure"  # ADDED: From masterplan
          - "get_agent_specs: GET /agents/specs"  # ADDED: List agent specifications
          - "create_agent_spec: POST /agents/specs"  # ADDED: Create agent specification
          - "delete_agent: DELETE /agents/{id}"
        content_structure: |
          from typing import Dict, Any, List, Optional
          from fastapi import APIRouter, HTTPException, Depends, Query, Body
          from fastapi.responses import JSONResponse, StreamingResponse
          from pydantic import BaseModel, Field
          import logging
          from uuid import uuid4
          from datetime import datetime
          import json
          
          # VERIFIED: ADK imports match official documentation
          from google.adk.agents import LlmAgent, SequentialAgent, ParallelAgent, LoopAgent, BaseAgent
          from google.adk.runners import InMemoryRunner
          from google.adk.tools import FunctionTool
          
          from ...core.agent_factory import AgentFactory  # CORRECTED: From r2-t01
          from ...core.specification import SpecificationParser
          from ...services.configuration import ConfigurationService  # ADDED: Spec loading
          from ..models import (
              AgentComposeRequest,  # CORRECTED: Composition-based
              AgentReconfigureRequest,  # ADDED
              AgentResponse,
              AgentSpecResponse,  # ADDED
              AgentSpecCreateRequest,  # ADDED
              AgentListResponse
          )
          from ..auth import get_current_user
          from ..dependencies import get_agent_factory, get_runner, get_config_service
          
          logger = logging.getLogger(__name__)
          router = APIRouter(prefix="/agents", tags=["agents"])
          
          # CORRECTED: Removed in-memory repository - using specification-driven approach
          
          @router.post("/compose", response_model=AgentResponse)  # CORRECTED: Composition endpoint
          async def compose_agent(
              request: AgentComposeRequest,
              user = Depends(get_current_user),
              factory: AgentFactory = Depends(get_agent_factory)
          ):
              """Create agent from specification"""  # CORRECTED: Spec-driven
              try:
                  # Load specification from specs directory
                  agent_spec = factory.load_agent_spec(request.spec_name)
                  
                  # Apply runtime context if provided
                  if request.context:
                      agent_spec = factory.apply_context(agent_spec, request.context)
                  
                  # Build agent instance
                  agent_instance = factory.build_agent(agent_spec, request.context)
                  
                  # Store agent instance for execution
                  agent_id = factory.register_agent_instance(agent_instance, agent_spec)
                  
                  return AgentResponse(
                      id=agent_id,
                      name=agent_spec["metadata"]["name"],
                      type=agent_spec["spec"]["agent"]["type"],
                      status="ready",
                      created_at=datetime.now(),
                      specification=agent_spec
                  )
                  
              except Exception as e:
                  logger.error(f"Failed to compose agent: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.put("/{agent_id}/reconfigure", response_model=AgentResponse)  # ADDED: From masterplan
          async def reconfigure_agent(
              agent_id: str,
              request: AgentReconfigureRequest,
              user = Depends(get_current_user),
              factory: AgentFactory = Depends(get_agent_factory)
          ):
              """Modify agent configuration"""
              try:
                  # Get existing agent
                  agent_data = factory.get_agent_instance(agent_id)
                  if not agent_data:
                      raise HTTPException(status_code=404, detail=f"Agent {agent_id} not found")
                  
                  # Apply configuration changes
                  updated_spec = factory.apply_configuration_update(
                      agent_data["spec"], 
                      request.configuration_updates
                  )
                  
                  # Rebuild agent with new configuration
                  new_agent = factory.build_agent(updated_spec, request.context)
                  factory.update_agent_instance(agent_id, new_agent, updated_spec)
                  
                  return AgentResponse(
                      id=agent_id,
                      name=updated_spec["metadata"]["name"],
                      type=updated_spec["spec"]["agent"]["type"],
                      status="reconfigured",
                      created_at=agent_data["created_at"],
                      specification=updated_spec
                  )
                  
              except Exception as e:
                  logger.error(f"Failed to reconfigure agent: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.get("/specs", response_model=List[AgentSpecResponse])  # ADDED: From masterplan
          async def get_agent_specs(
              category: Optional[str] = Query(None),
              user = Depends(get_current_user),
              config_service = Depends(get_config_service)
          ):
              """List available agent specifications"""
              specs = config_service.list_agent_specs(category=category)
              return [
                  AgentSpecResponse(
                      name=spec["metadata"]["name"],
                      version=spec["metadata"]["version"],
                      description=spec["metadata"].get("description"),
                      type=spec["spec"]["agent"]["type"],
                      tags=spec["metadata"].get("tags", []),
                      created_at=spec["metadata"].get("created_at")
                  )
                  for spec in specs
              ]
          
          @router.post("/specs", response_model=AgentSpecResponse)  # ADDED: From masterplan
          async def create_agent_spec(
              request: AgentSpecCreateRequest,
              user = Depends(get_current_user),
              config_service = Depends(get_config_service)
          ):
              """Create new agent specification"""
              try:
                  # Validate specification
                  config_service.validate_agent_spec(request.specification)
                  
                  # Store specification
                  spec_name = config_service.store_agent_spec(request.specification)
                  
                  return AgentSpecResponse(
                      name=spec_name,
                      version=request.specification["metadata"]["version"],
                      description=request.specification["metadata"].get("description"),
                      type=request.specification["spec"]["agent"]["type"],
                      tags=request.specification["metadata"].get("tags", []),
                      created_at=datetime.now()
                  )
                  
              except Exception as e:
                  logger.error(f"Failed to create agent spec: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.delete("/{agent_id}")
          async def delete_agent(
              agent_id: str,
              user = Depends(get_current_user),
              factory: AgentFactory = Depends(get_agent_factory)
          ):
              """Delete an agent instance"""
              if not factory.get_agent_instance(agent_id):
                  raise HTTPException(status_code=404, detail=f"Agent {agent_id} not found")
              
              factory.delete_agent_instance(agent_id)
              return {"status": "deleted", "agent_id": agent_id}
      
      - path: "services/agent-engine/src/api/routes/sessions.py"
        purpose: "Session management API endpoints with multi-backend support"  # CORRECTED
        exports:
          - "router: Session API router"
          - "create_session: POST /sessions/create"  # CORRECTED: From masterplan
          - "get_session: GET /sessions/{session_id}"
          - "update_session_state: PUT /sessions/{id}/state"  # ADDED: From masterplan
          - "get_session_history: GET /sessions/{id}/history"  # ADDED: From masterplan
          - "fork_session: POST /sessions/{session_id}/fork"
          - "delete_session: DELETE /sessions/{id}"  # ADDED: From masterplan
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends
          from google.adk.sessions import InMemorySessionService  # VERIFIED: ADK import
          from google.adk.runners import InMemoryRunner  # VERIFIED: ADK import
          
          from ...core.session import SessionOrchestrator  # From r5-t01
          from ..models import (
              SessionCreateRequest,
              SessionResponse,
              SessionUpdateRequest,
              SessionForkRequest,
              SessionHistoryResponse  # ADDED
          )
          from ..dependencies import get_session_orchestrator
          
          router = APIRouter(prefix="/sessions", tags=["sessions"])
          
          @router.post("/create", response_model=SessionResponse)  # CORRECTED: Path from masterplan
          async def create_session(
              request: SessionCreateRequest,
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Create session with specified configuration"""  # CORRECTED: Config support
              context = await orchestrator.create_session(
                  user_id=request.user_id,
                  app_name=request.app_name,
                  session_id=request.session_id,
                  config=request.config,  # ADDED: Configuration support
                  persistence_backend=request.persistence_backend  # ADDED: Backend selection
              )
              return SessionResponse.from_context(context)
          
          @router.get("/{session_id}", response_model=SessionResponse)
          async def get_session(
              session_id: str,
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Get session by ID"""
              context = await orchestrator.get_session(session_id)
              if not context:
                  raise HTTPException(status_code=404, detail="Session not found")
              return SessionResponse.from_context(context)
          
          @router.put("/{session_id}/state")  # ADDED: From masterplan
          async def update_session_state(
              session_id: str,
              request: SessionUpdateRequest,
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Update session state"""
              success = await orchestrator.update_session_state(
                  session_id,
                  state_update=request.state,
                  metadata_update=request.metadata
              )
              if not success:
                  raise HTTPException(status_code=400, detail="State update failed")
              return {"status": "updated"}
          
          @router.get("/{session_id}/history", response_model=SessionHistoryResponse)  # ADDED
          async def get_session_history(
              session_id: str,
              limit: int = Query(100),
              offset: int = Query(0),
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Get conversation history"""
              history = await orchestrator.get_session_history(
                  session_id, limit=limit, offset=offset
              )
              if history is None:
                  raise HTTPException(status_code=404, detail="Session not found")
              return SessionHistoryResponse(
                  session_id=session_id,
                  messages=history["messages"],
                  total=history["total"],
                  limit=limit,
                  offset=offset
              )
          
          @router.post("/{session_id}/fork", response_model=SessionResponse)
          async def fork_session(
              session_id: str,
              request: SessionForkRequest,
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Fork session for branching"""
              new_context = await orchestrator.fork_session(
                  source_session_id=session_id,
                  new_session_id=request.new_session_id,
                  copy_messages=request.copy_messages,
                  metadata_overrides=request.metadata_overrides
              )
              if not new_context:
                  raise HTTPException(status_code=400, detail="Fork failed")
              return SessionResponse.from_context(new_context)
          
          @router.delete("/{session_id}")  # ADDED: From masterplan
          async def delete_session(
              session_id: str,
              orchestrator: SessionOrchestrator = Depends(get_session_orchestrator)
          ):
              """Clean up session"""
              success = await orchestrator.delete_session(session_id)
              if not success:
                  raise HTTPException(status_code=404, detail="Session not found")
              return {"status": "deleted", "session_id": session_id}
      
      - path: "services/agent-engine/src/api/routes/workflows.py"
        purpose: "Workflow execution API endpoints with template management"  # CORRECTED
        exports:
          - "router: Workflow API router"
          - "execute_workflow: POST /workflows/execute"  # CORRECTED: Primary execution endpoint
          - "get_workflow_templates: GET /workflows/templates"  # ADDED: From masterplan
          - "create_workflow_template: POST /workflows/templates"  # ADDED: From masterplan
          - "get_workflow_status: GET /workflows/{workflow_id}/status"
          - "stream_workflow: POST /workflows/{id}/stream"  # ADDED: From masterplan
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends, Query
          from fastapi.responses import StreamingResponse
          from google.adk.agents import SequentialAgent, ParallelAgent, LoopAgent  # VERIFIED: ADK imports
          from google.adk.runners import InMemoryRunner  # VERIFIED: ADK import
          
          from ...core.workflow import WorkflowEngine  # From r4-t01
          from ..models import (
              WorkflowExecuteRequest,  # CORRECTED: Primary execution model
              WorkflowTemplateCreateRequest,  # ADDED
              WorkflowTemplateResponse,  # ADDED
              WorkflowResponse,
              WorkflowStatusResponse
          )
          from ..dependencies import get_workflow_engine
          
          router = APIRouter(prefix="/workflows", tags=["workflows"])
          
          @router.post("/execute")  # CORRECTED: Primary execution endpoint
          async def execute_workflow(
              request: WorkflowExecuteRequest,
              stream: bool = Query(False),
              engine: WorkflowEngine = Depends(get_workflow_engine)
          ):
              """Execute workflow from template"""  # CORRECTED: Template-driven
              try:
                  if stream:
                      async def generate():
                          async for event in engine.execute_workflow_stream(
                              template_name=request.template_name,
                              input_data=request.input_data,
                              context=request.context,
                              session_id=request.session_id
                          ):
                              yield f"data: {json.dumps(event)}\\n\\n"
                      
                      return StreamingResponse(
                          generate(),
                          media_type="text/event-stream"
                      )
                  else:
                      result = await engine.execute_workflow(
                          template_name=request.template_name,
                          input_data=request.input_data,
                          context=request.context,
                          session_id=request.session_id
                      )
                      return result
                      
              except Exception as e:
                  logger.error(f"Workflow execution failed: {e}")
                  raise HTTPException(status_code=500, detail=str(e))
          
          @router.get("/templates", response_model=List[WorkflowTemplateResponse])  # ADDED
          async def get_workflow_templates(
              category: Optional[str] = Query(None),
              engine: WorkflowEngine = Depends(get_workflow_engine)
          ):
              """List workflow templates"""
              templates = engine.list_workflow_templates(category=category)
              return [
                  WorkflowTemplateResponse(
                      name=template["metadata"]["name"],
                      type=template["spec"]["type"],
                      description=template["metadata"].get("description"),
                      tags=template["metadata"].get("tags", []),
                      created_at=template["metadata"].get("created_at")
                  )
                  for template in templates
              ]
          
          @router.post("/templates", response_model=WorkflowTemplateResponse)  # ADDED
          async def create_workflow_template(
              request: WorkflowTemplateCreateRequest,
              engine: WorkflowEngine = Depends(get_workflow_engine)
          ):
              """Create workflow template"""
              try:
                  template_id = await engine.register_template(
                      name=request.name,
                      specification=request.specification,
                      description=request.description
                  )
                  return WorkflowTemplateResponse(
                      name=template_id,
                      type=request.specification["spec"]["type"],
                      description=request.description,
                      tags=request.specification["metadata"].get("tags", []),
                      created_at=datetime.now()
                  )
                  
              except Exception as e:
                  logger.error(f"Failed to create workflow template: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.get("/{workflow_id}/status", response_model=WorkflowStatusResponse)
          async def get_workflow_status(
              workflow_id: str,
              engine: WorkflowEngine = Depends(get_workflow_engine)
          ):
              """Get workflow execution status"""
              status = await engine.get_workflow_status(workflow_id)
              if not status:
                  raise HTTPException(status_code=404, detail="Workflow not found")
              return WorkflowStatusResponse(**status)
          
          @router.post("/{workflow_id}/stream")  # ADDED: From masterplan
          async def stream_workflow_events(
              workflow_id: str,
              engine: WorkflowEngine = Depends(get_workflow_engine)
          ):
              """Stream execution events (SSE)"""
              async def generate():
                  async for event in engine.stream_workflow_events(workflow_id):
                      yield f"data: {json.dumps(event)}\\n\\n"
              
              return StreamingResponse(
                  generate(),
                  media_type="text/event-stream"
              )
      
      # ADDED: Tool Registry API (Missing from original task)
      - path: "services/agent-engine/src/api/routes/tools.py"
        purpose: "Tool registry API endpoints for runtime tool management"
        exports:
          - "router: Tool registry API router"
          - "register_tool: POST /tools/register"
          - "get_tools: GET /tools/registry"
          - "update_tool: PUT /tools/{name}/update"
          - "delete_tool: DELETE /tools/{name}"
          - "create_tool_collection: POST /tools/collections"
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends
          from google.adk.tools import FunctionTool  # VERIFIED: ADK import
          
          from ...core.tools import ToolRegistry  # From r3-t01
          from ..models import (
              ToolRegisterRequest,
              ToolResponse,
              ToolListResponse,
              ToolUpdateRequest,
              ToolCollectionRequest
          )
          from ..dependencies import get_tool_registry
          
          router = APIRouter(prefix="/tools", tags=["tools"])
          
          @router.post("/register", response_model=ToolResponse)
          async def register_tool(
              request: ToolRegisterRequest,
              registry: ToolRegistry = Depends(get_tool_registry)
          ):
              """Register new tool from specification"""
              try:
                  tool_id = registry.register_tool(request.specification)
                  return ToolResponse(
                      name=request.specification["metadata"]["name"],
                      description=request.specification["spec"]["description"],
                      categories=request.specification["spec"]["categories"],
                      status="registered",
                      created_at=datetime.now()
                  )
              except Exception as e:
                  logger.error(f"Tool registration failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.get("/registry", response_model=ToolListResponse)
          async def get_tools(
              category: Optional[str] = Query(None),
              registry: ToolRegistry = Depends(get_tool_registry)
          ):
              """List available tools"""
              tools = registry.list_tools(category=category)
              return ToolListResponse(
                  tools=[
                      ToolResponse(
                          name=tool["name"],
                          description=tool["spec"]["description"],
                          categories=tool["spec"]["categories"],
                          status="available",
                          created_at=tool["created_at"]
                      )
                      for tool in tools
                  ],
                  total=len(tools)
              )
          
          @router.put("/{tool_name}/update", response_model=ToolResponse)
          async def update_tool(
              tool_name: str,
              request: ToolUpdateRequest,
              registry: ToolRegistry = Depends(get_tool_registry)
          ):
              """Update tool definition"""
              try:
                  success = registry.update_tool(tool_name, request.specification)
                  if not success:
                      raise HTTPException(status_code=404, detail="Tool not found")
                  
                  return ToolResponse(
                      name=tool_name,
                      description=request.specification["spec"]["description"],
                      categories=request.specification["spec"]["categories"],
                      status="updated",
                      created_at=datetime.now()
                  )
              except Exception as e:
                  logger.error(f"Tool update failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.delete("/{tool_name}")
          async def delete_tool(
              tool_name: str,
              registry: ToolRegistry = Depends(get_tool_registry)
          ):
              """Remove tool"""
              success = registry.delete_tool(tool_name)
              if not success:
                  raise HTTPException(status_code=404, detail="Tool not found")
              return {"status": "deleted", "tool_name": tool_name}
          
          @router.post("/collections", response_model=dict)
          async def create_tool_collection(
              request: ToolCollectionRequest,
              registry: ToolRegistry = Depends(get_tool_registry)
          ):
              """Create tool collections"""
              try:
                  collection_id = registry.create_collection(
                      name=request.name,
                      tool_names=request.tool_names,
                      description=request.description
                  )
                  return {
                      "collection_id": collection_id,
                      "status": "created",
                      "tool_count": len(request.tool_names)
                  }
              except Exception as e:
                  logger.error(f"Collection creation failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
      
      # ADDED: Model Management API (Missing from original task)
      - path: "services/agent-engine/src/api/routes/models.py"
        purpose: "Model management API endpoints for provider abstraction"
        exports:
          - "router: Model management API router"
          - "get_available_models: GET /models/available"
          - "configure_model: POST /models/configure"
          - "update_fallback: PUT /models/fallback"
          - "get_model_health: GET /models/health"
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends
          from ...core.models import ModelAbstraction  # From core layer
          from ..models import (
              ModelConfigRequest,
              ModelResponse,
              ModelListResponse,
              ModelFallbackRequest,
              ModelHealthResponse
          )
          from ..dependencies import get_model_abstraction
          
          router = APIRouter(prefix="/models", tags=["models"])
          
          @router.get("/available", response_model=ModelListResponse)
          async def get_available_models(
              provider: Optional[str] = Query(None),
              model_abstraction: ModelAbstraction = Depends(get_model_abstraction)
          ):
              """List configured models"""
              models = model_abstraction.list_available_models(provider=provider)
              return ModelListResponse(
                  models=[
                      ModelResponse(
                          name=model["name"],
                          provider=model["provider"],
                          status=model["status"],
                          capabilities=model["capabilities"]
                      )
                      for model in models
                  ],
                  total=len(models)
              )
          
          @router.post("/configure", response_model=ModelResponse)
          async def configure_model(
              request: ModelConfigRequest,
              model_abstraction: ModelAbstraction = Depends(get_model_abstraction)
          ):
              """Configure model settings"""
              try:
                  config_id = model_abstraction.configure_model(
                      name=request.name,
                      provider=request.provider,
                      parameters=request.parameters,
                      fallbacks=request.fallbacks
                  )
                  return ModelResponse(
                      name=request.name,
                      provider=request.provider,
                      status="configured",
                      capabilities=request.parameters.get("capabilities", [])
                  )
              except Exception as e:
                  logger.error(f"Model configuration failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.put("/fallback", response_model=dict)
          async def update_fallback(
              request: ModelFallbackRequest,
              model_abstraction: ModelAbstraction = Depends(get_model_abstraction)
          ):
              """Update fallback strategies"""
              try:
                  success = model_abstraction.update_fallback_strategy(
                      primary_model=request.primary_model,
                      fallback_models=request.fallback_models,
                      trigger_conditions=request.trigger_conditions
                  )
                  if not success:
                      raise HTTPException(status_code=400, detail="Fallback update failed")
                  return {"status": "updated", "strategy": "configured"}
              except Exception as e:
                  logger.error(f"Fallback update failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.get("/health", response_model=ModelHealthResponse)
          async def get_model_health(
              model_abstraction: ModelAbstraction = Depends(get_model_abstraction)
          ):
              """Check model availability"""
              health_status = model_abstraction.check_model_health()
              return ModelHealthResponse(
                  overall_status=health_status["overall"],
                  models=health_status["models"],
                  checked_at=datetime.now()
              )
      
      # ADDED: Configuration Management API (Missing from original task)
      - path: "services/agent-engine/src/api/routes/specs.py"
        purpose: "Configuration management API endpoints for specifications"
        exports:
          - "router: Configuration management API router"
          - "get_agent_specs: GET /specs/agents"
          - "get_workflow_specs: GET /specs/workflows"
          - "get_tool_specs: GET /specs/tools"
          - "validate_spec: POST /specs/validate"
          - "update_spec: PUT /specs/{type}/{name}"
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends
          from ...services.configuration import ConfigurationService
          from ..models import (
              SpecValidationRequest,
              SpecValidationResponse,
              SpecUpdateRequest,
              SpecListResponse
          )
          from ..dependencies import get_config_service
          
          router = APIRouter(prefix="/specs", tags=["specifications"])
          
          @router.get("/agents", response_model=SpecListResponse)
          async def get_agent_specs(
              config_service: ConfigurationService = Depends(get_config_service)
          ):
              """List agent specifications"""
              specs = config_service.list_specifications("agents")
              return SpecListResponse(
                  specifications=specs,
                  total=len(specs),
                  type="agents"
              )
          
          @router.get("/workflows", response_model=SpecListResponse)
          async def get_workflow_specs(
              config_service: ConfigurationService = Depends(get_config_service)
          ):
              """List workflow templates"""
              specs = config_service.list_specifications("workflows")
              return SpecListResponse(
                  specifications=specs,
                  total=len(specs),
                  type="workflows"
              )
          
          @router.get("/tools", response_model=SpecListResponse)
          async def get_tool_specs(
              config_service: ConfigurationService = Depends(get_config_service)
          ):
              """List tool specifications"""
              specs = config_service.list_specifications("tools")
              return SpecListResponse(
                  specifications=specs,
                  total=len(specs),
                  type="tools"
              )
          
          @router.post("/validate", response_model=SpecValidationResponse)
          async def validate_spec(
              request: SpecValidationRequest,
              config_service: ConfigurationService = Depends(get_config_service)
          ):
              """Validate specification format"""
              try:
                  result = config_service.validate_specification(
                      spec_type=request.spec_type,
                      specification=request.specification
                  )
                  return SpecValidationResponse(
                      valid=result["valid"],
                      errors=result.get("errors", []),
                      warnings=result.get("warnings", [])
                  )
              except Exception as e:
                  logger.error(f"Specification validation failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
          
          @router.put("/{spec_type}/{spec_name}")
          async def update_spec(
              spec_type: str,
              spec_name: str,
              request: SpecUpdateRequest,
              config_service: ConfigurationService = Depends(get_config_service)
          ):
              """Update specification"""
              try:
                  success = config_service.update_specification(
                      spec_type=spec_type,
                      spec_name=spec_name,
                      specification=request.specification
                  )
                  if not success:
                      raise HTTPException(status_code=404, detail="Specification not found")
                  return {"status": "updated", "spec_type": spec_type, "name": spec_name}
              except Exception as e:
                  logger.error(f"Specification update failed: {e}")
                  raise HTTPException(status_code=400, detail=str(e))
      
      # ADDED: Monitoring & Observability API (Missing from original task)
      - path: "services/agent-engine/src/api/routes/monitoring.py"
        purpose: "Monitoring and observability API endpoints"
        exports:
          - "router: Monitoring API router"
          - "health_check: GET /health"
          - "get_metrics: GET /metrics"
          - "stream_events: GET /events/stream"
          - "get_session_trace: GET /sessions/{id}/trace"
          - "get_usage_analytics: GET /analytics/usage"
        content_structure: |
          from fastapi import APIRouter, HTTPException, Depends
          from fastapi.responses import StreamingResponse
          from ...services.monitoring import MonitoringService
          from ..models import (
              HealthResponse,
              MetricsResponse,
              TraceResponse,
              AnalyticsResponse
          )
          from ..dependencies import get_monitoring_service
          
          router = APIRouter(tags=["monitoring"])
          
          @router.get("/health", response_model=HealthResponse)
          async def health_check(
              monitoring: MonitoringService = Depends(get_monitoring_service)
          ):
              """Service health with ADK status"""
              health_status = monitoring.get_health_status()
              return HealthResponse(
                  status=health_status["overall"],
                  services=health_status["services"],
                  adk_status=health_status["adk"],
                  timestamp=datetime.now()
              )
          
          @router.get("/metrics", response_model=MetricsResponse)
          async def get_metrics(
              monitoring: MonitoringService = Depends(get_monitoring_service)
          ):
              """Operational metrics"""
              metrics = monitoring.get_operational_metrics()
              return MetricsResponse(**metrics)
          
          @router.get("/events/stream")
          async def stream_events(
              monitoring: MonitoringService = Depends(get_monitoring_service)
          ):
              """Real-time event stream (SSE)"""
              async def generate():
                  async for event in monitoring.stream_events():
                      yield f"data: {json.dumps(event)}\\n\\n"
              
              return StreamingResponse(
                  generate(),
                  media_type="text/event-stream"
              )
          
          @router.get("/sessions/{session_id}/trace", response_model=TraceResponse)
          async def get_session_trace(
              session_id: str,
              monitoring: MonitoringService = Depends(get_monitoring_service)
          ):
              """Get execution trace"""
              trace = monitoring.get_session_trace(session_id)
              if not trace:
                  raise HTTPException(status_code=404, detail="Trace not found")
              return TraceResponse(**trace)
          
          @router.get("/analytics/usage", response_model=AnalyticsResponse)
          async def get_usage_analytics(
              days: int = Query(7, ge=1, le=90),
              monitoring: MonitoringService = Depends(get_monitoring_service)
          ):
              """Usage analytics"""
              analytics = monitoring.get_usage_analytics(days=days)
              return AnalyticsResponse(**analytics)
      
      - path: "services/agent-engine/src/api/models.py"
        purpose: "API request/response models with complete coverage"  # CORRECTED
        exports:
          # CORRECTED: Updated model exports to match new API structure
          - "AgentComposeRequest"  # CORRECTED: Composition-based
          - "AgentReconfigureRequest"  # ADDED
          - "AgentSpecCreateRequest"  # ADDED
          - "AgentSpecResponse"  # ADDED
          - "AgentResponse"
          - "SessionCreateRequest"
          - "SessionResponse"
          - "SessionHistoryResponse"  # ADDED
          - "WorkflowExecuteRequest"  # CORRECTED: Primary execution model
          - "WorkflowTemplateCreateRequest"  # ADDED
          - "WorkflowTemplateResponse"  # ADDED
          - "WorkflowResponse"
          - "ToolRegisterRequest"  # ADDED
          - "ToolResponse"  # ADDED
          - "ModelConfigRequest"  # ADDED
          - "ModelResponse"  # ADDED
          - "HealthResponse"  # ADDED
        content_structure: |
          from typing import Dict, Any, List, Optional
          from datetime import datetime
          from pydantic import BaseModel, Field
          from enum import Enum
          
          class AgentType(str, Enum):
              LLM = "llm"
              SEQUENTIAL = "sequential"
              PARALLEL = "parallel"
              LOOP = "loop"
              CUSTOM = "custom"
          
          class PersistenceBackend(str, Enum):  # ADDED
              MEMORY = "memory"
              REDIS = "redis"
              VERTEX = "vertex"
          
          # CORRECTED: Composition-based agent models
          class AgentComposeRequest(BaseModel):
              """Request to compose agent from specification"""
              spec_name: str = Field(..., description="Name of agent specification")
              context: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Runtime context")
              tags: List[str] = Field(default_factory=list)
          
          class AgentReconfigureRequest(BaseModel):  # ADDED
              """Request to reconfigure existing agent"""
              configuration_updates: Dict[str, Any] = Field(..., description="Configuration changes")
              context: Optional[Dict[str, Any]] = Field(default_factory=dict)
          
          class AgentSpecCreateRequest(BaseModel):  # ADDED
              """Request to create agent specification"""
              specification: Dict[str, Any] = Field(..., description="Complete agent specification")
          
          class AgentSpecResponse(BaseModel):  # ADDED
              """Agent specification information"""
              name: str
              version: str
              description: Optional[str]
              type: str
              tags: List[str]
              created_at: datetime
          
          class AgentResponse(BaseModel):
              """Agent information response"""
              id: str
              name: str
              type: str
              status: str
              created_at: datetime
              specification: Dict[str, Any]
              metadata: Dict[str, Any] = Field(default_factory=dict)
          
          class SessionCreateRequest(BaseModel):
              """Request to create session with configuration"""  # CORRECTED
              user_id: str
              app_name: str
              session_id: Optional[str] = None
              config: Dict[str, Any] = Field(default_factory=dict)  # ADDED
              persistence_backend: PersistenceBackend = PersistenceBackend.MEMORY  # ADDED
              initial_state: Dict[str, Any] = Field(default_factory=dict)
          
          class SessionHistoryResponse(BaseModel):  # ADDED
              """Session conversation history"""
              session_id: str
              messages: List[Dict[str, Any]]
              total: int
              limit: int
              offset: int
          
          # CORRECTED: Workflow-centric execution models
          class WorkflowExecuteRequest(BaseModel):
              """Request to execute workflow from template"""  # CORRECTED
              template_name: str = Field(..., description="Workflow template name")
              input_data: Dict[str, Any] = Field(..., description="Input data for workflow")
              context: Dict[str, Any] = Field(default_factory=dict, description="Execution context")
              session_id: Optional[str] = Field(None, description="Session ID for stateful execution")
              timeout: Optional[int] = Field(None, description="Execution timeout in seconds")
          
          class WorkflowTemplateCreateRequest(BaseModel):  # ADDED
              """Request to create workflow template"""
              name: str
              specification: Dict[str, Any]
              description: Optional[str] = None
              tags: List[str] = Field(default_factory=list)
          
          class WorkflowTemplateResponse(BaseModel):  # ADDED
              """Workflow template information"""
              name: str
              type: str
              description: Optional[str]
              tags: List[str]
              created_at: datetime
          
          # ADDED: Tool Registry Models
          class ToolRegisterRequest(BaseModel):
              """Request to register tool"""
              specification: Dict[str, Any] = Field(..., description="Tool specification")
          
          class ToolResponse(BaseModel):
              """Tool information response"""
              name: str
              description: str
              categories: List[str]
              status: str
              created_at: datetime
          
          class ToolListResponse(BaseModel):
              """List of tools response"""
              tools: List[ToolResponse]
              total: int
          
          # ADDED: Model Management Models
          class ModelConfigRequest(BaseModel):
              """Request to configure model"""
              name: str
              provider: str
              parameters: Dict[str, Any]
              fallbacks: List[str] = Field(default_factory=list)
          
          class ModelResponse(BaseModel):
              """Model information response"""
              name: str
              provider: str
              status: str
              capabilities: List[str]
          
          # ADDED: Monitoring Models
          class HealthResponse(BaseModel):
              """Service health response"""
              status: str
              services: Dict[str, str]
              adk_status: Dict[str, Any]  # CORRECTED: ADK status
              timestamp: datetime
          
          class MetricsResponse(BaseModel):
              """Operational metrics response"""
              agent_executions: int
              workflow_executions: int
              active_sessions: int
              tool_invocations: int
              average_response_time: float
              error_rate: float
              timestamp: datetime
      
      - path: "services/agent-engine/src/api/dependencies.py"
        purpose: "FastAPI dependency injection with complete service coverage"  # CORRECTED
        exports:
          - "get_agent_factory"
          - "get_session_orchestrator"
          - "get_workflow_engine"
          - "get_tool_registry"  # ADDED
          - "get_model_abstraction"  # ADDED
          - "get_config_service"  # ADDED
          - "get_monitoring_service"  # ADDED
          - "get_runner"
        content_structure: |
          from functools import lru_cache
          from google.adk.runners import InMemoryRunner  # VERIFIED: ADK import
          
          from ..core.agent_factory import AgentFactory  # From r2-t01
          from ..core.session import SessionOrchestrator  # From r5-t01
          from ..core.workflow import WorkflowEngine  # From r4-t01
          from ..core.tools import ToolRegistry  # From r3-t01
          from ..core.models import ModelAbstraction  # ADDED
          from ..services.configuration import ConfigurationService  # ADDED
          from ..services.monitoring import MonitoringService  # ADDED
          
          @lru_cache()
          def get_agent_factory() -> AgentFactory:
              return AgentFactory()
          
          @lru_cache()
          def get_session_orchestrator() -> SessionOrchestrator:
              # CORRECTED: Configuration-driven backend selection
              return SessionOrchestrator(backend_type="memory")
          
          @lru_cache()
          def get_workflow_engine() -> WorkflowEngine:
              return WorkflowEngine()
          
          @lru_cache()  # ADDED
          def get_tool_registry() -> ToolRegistry:
              return ToolRegistry()
          
          @lru_cache()  # ADDED
          def get_model_abstraction() -> ModelAbstraction:
              return ModelAbstraction()
          
          @lru_cache()  # ADDED
          def get_config_service() -> ConfigurationService:
              return ConfigurationService()
          
          @lru_cache()  # ADDED
          def get_monitoring_service() -> MonitoringService:
              return MonitoringService()
          
          @lru_cache()
          def get_runner() -> InMemoryRunner:
              # VERIFIED: ADK pattern - create runner instance
              return InMemoryRunner()
      
      - path: "services/agent-engine/src/api/auth.py"
        purpose: "API authentication and authorization with service tokens"  # CORRECTED
        exports:
          - "get_current_user"
          - "require_service_token"  # CORRECTED: Service token auth
          - "check_permissions"
          - "audit_log_action"  # ADDED: Audit logging
      
      - path: "services/agent-engine/tests/test_api.py"
        purpose: "Comprehensive API endpoint tests"  # CORRECTED
        test_categories:
          - "Agent composition endpoints"  # CORRECTED
          - "Session management endpoints"
          - "Workflow execution endpoints"
          - "Tool registry endpoints"  # ADDED
          - "Model management endpoints"  # ADDED
          - "Configuration management endpoints"  # ADDED
          - "Monitoring endpoints"  # ADDED
          - "Service token authentication"  # CORRECTED
          - "Error handling and validation"
          - "Streaming responses"  # ADDED
          - "ADK integration"  # ADDED
    
    uses_from_previous:
      - source: "r5-t01"
        component: "SessionOrchestrator"
        usage: "Multi-backend session API implementation"  # CORRECTED
      - source: "r4-t01"
        component: "WorkflowEngine"
        usage: "Template-driven workflow API implementation"  # CORRECTED
      - source: "r3-t01"  # ADDED
        component: "ToolRegistry"
        usage: "Runtime tool management API"
      - source: "r2-t01"
        component: "AgentFactory"
        usage: "Specification-driven agent composition"  # CORRECTED
    
  implementation_steps:
    - step: "Create comprehensive API models"  # CORRECTED
      implementation_notes: |
        - Complete request/response schemas for all endpoints
        - Pydantic models with proper validation
        - ADK-compatible data structures
        - Specification-driven model design
        
    - step: "Implement specification-based agent endpoints"  # CORRECTED
      implementation_notes: |
        - Agent composition from specifications
        - Agent reconfiguration support
        - Specification management (CRUD)
        - Integration with AgentFactory from r2-t01
        
    - step: "Build enhanced session endpoints"  # CORRECTED
      implementation_notes: |
        - Multi-backend session support
        - Session state management API
        - Conversation history access
        - Session forking and cleanup
        
    - step: "Add workflow-centric execution endpoints"  # CORRECTED
      implementation_notes: |
        - Template-driven workflow execution
        - Workflow template management
        - Streaming execution support
        - Status tracking and monitoring
        
    - step: "Implement tool registry endpoints"  # ADDED
      implementation_notes: |
        - Runtime tool registration
        - Tool validation and testing
        - Tool collections and categories
        - Integration with ToolRegistry from r3-t01
        
    - step: "Add model management endpoints"  # ADDED
      implementation_notes: |
        - Model configuration API
        - Fallback strategy management
        - Health monitoring
        - Provider abstraction
        
    - step: "Create configuration management endpoints"  # ADDED
      implementation_notes: |
        - Specification CRUD operations
        - Validation endpoints
        - Version management
        - File-based spec integration
        
    - step: "Implement monitoring and observability"  # ADDED
      implementation_notes: |
        - Health checks with ADK status
        - Operational metrics
        - Event streaming (SSE)
        - Usage analytics
        
    - step: "Add service token authentication"  # CORRECTED
      implementation_notes: |
        - Service token validation
        - User context management
        - Role-based permissions
        - Comprehensive audit logging
        
  validation:
    commands:
      - description: "Test comprehensive API endpoints"  # CORRECTED
        command: "cd services/agent-engine && pytest tests/test_api.py -v"
        expected: "All endpoint tests pass including new tool, model, config, and monitoring APIs"
        
      - description: "Run API server with all endpoints"  # CORRECTED
        command: "cd services/agent-engine && uvicorn src.main:app --reload"
        expected: "Server starts on port 8001 with complete API coverage"
        
      - description: "Test agent composition endpoint"  # CORRECTED
        command: "curl -X POST http://localhost:8001/api/v1/agents/compose -H 'Content-Type: application/json' -d '{\"spec_name\": \"example-agent\", \"context\": {}}'"
        expected: "Agent composition from specification succeeds"
        
      - description: "Test workflow execution endpoint"  # ADDED
        command: "curl -X POST http://localhost:8001/api/v1/workflows/execute -H 'Content-Type: application/json' -d '{\"template_name\": \"example-workflow\", \"input_data\": {}}'"
        expected: "Workflow execution from template succeeds"
        
      - description: "Test tool registration endpoint"  # ADDED
        command: "curl -X GET http://localhost:8001/api/v1/tools/registry"
        expected: "Tool registry endpoint responds with available tools"
        
      - description: "Test health check with ADK status"  # ADDED
        command: "curl -X GET http://localhost:8001/api/v1/health"
        expected: "Health check includes ADK status information"
        
    success_criteria:
      - "All specification-driven endpoints implemented"  # CORRECTED
      - "Complete API coverage per MASTERPLAN.md"  # ADDED
      - "Service token authentication working"  # CORRECTED
      - "Streaming responses functional"
      - "Tool registry API operational"  # ADDED
      - "Model management API functional"  # ADDED
      - "Configuration management working"  # ADDED
      - "Monitoring endpoints active"  # ADDED
      - "ADK integration verified"  # ADDED
      - "Error handling robust across all endpoints"  # CORRECTED
      - "All comprehensive tests pass"  # CORRECTED
      
  dependencies:
    required_before:
      - task: "r5-t01"
        reason: "Need SessionOrchestrator for multi-backend session management"  # CORRECTED
      - task: "r4-t01"
        reason: "Need WorkflowEngine for template-driven execution"  # CORRECTED
      - task: "r3-t01"
        reason: "Need ToolRegistry for tool management API"
      - task: "r2-t01"
        reason: "Need AgentFactory for specification-driven composition"  # CORRECTED