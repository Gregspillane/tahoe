task:
  id: "r6-t02-websocket-support"
  name: "Implement WebSocket and SSE Support for Real-time Communication"  # CORRECTED: Added SSE as primary per MASTERPLAN
  description: "Add WebSocket endpoints and Server-Sent Events (SSE) for real-time agent execution, session updates, and event streaming with ADK integration"  # CORRECTED: Added SSE and ADK integration
  complexity: "medium"
  estimated_hours: 4  # CORRECTED: Increased due to dual implementation

  context:
    why: "WebSocket and SSE support enables real-time bidirectional communication for interactive agent sessions with ADK streaming integration"  # CORRECTED: Added SSE and ADK
    architectural_role: "Real-time communication layer for live agent interactions with dual transport support"  # CORRECTED: Added dual transport
    depends_on_tasks: ["r6-t01", "r4-t04"]
    enables_tasks: ["r6-t03"]
    references:
      masterplan: "@MASTERPLAN.md#real-time-processing"  # CORRECTED: Updated section reference
      architecture: "@memory-bank/architecture.md#websocket-design"
    
  implementation:
    creates:
      # ADDED: SSE endpoints per MASTERPLAN requirement
      - path: "services/agent-engine/src/api/streaming/"
        purpose: "Server-Sent Events implementation"  # ADDED: Primary streaming method per MASTERPLAN
        content:
          - "__init__.py"
          - "sse_endpoints.py"  # ADDED: SSE implementation
          - "event_generator.py"  # ADDED: Event generation for SSE
      
      - path: "services/agent-engine/src/api/streaming/sse_endpoints.py"
        purpose: "SSE endpoints for workflow and agent streaming"  # ADDED: Per MASTERPLAN API architecture
        exports:
          - "stream_workflow_events: SSE endpoint for workflow execution"  # ADDED: From MASTERPLAN
          - "stream_agent_events: SSE endpoint for agent execution"
          - "stream_session_events: SSE endpoint for session updates"
        content_structure: |
          from fastapi import APIRouter, BackgroundTasks
          from fastapi.responses import StreamingResponse
          from sse_starlette.sse import EventSourceResponse  # VERIFIED: Standard SSE library
          import asyncio
          import json
          from typing import AsyncGenerator
          
          # VERIFIED: ADK imports from documentation
          from google.adk.runners import InMemoryRunner
          from google.adk.agents import BaseAgent
          
          from ...core.agent_factory import AgentFactory  # CORRECTED: Use existing factory
          from ...core.workflow import WorkflowEngine  # CORRECTED: Use existing workflow engine
          from ...core.session import SessionOrchestrator  # CORRECTED: Use existing session management
          
          router = APIRouter(prefix="/stream", tags=["streaming"])
          
          @router.get("/workflows/{workflow_id}/events")
          async def stream_workflow_events(workflow_id: str, session_id: str):
              """Stream workflow execution events via SSE"""  # ADDED: Per MASTERPLAN API spec
              
              async def generate_events():
                  workflow_engine = WorkflowEngine()
                  # CORRECTED: Use ADK runner.run_async pattern from MASTERPLAN
                  async for event in workflow_engine.execute_workflow_stream(
                      template_name=workflow_id,
                      session_id=session_id
                  ):
                      yield {
                          "event": "workflow_event",
                          "data": json.dumps(event)
                      }
              
              return EventSourceResponse(generate_events())
          
          @router.get("/agents/{agent_id}/events")
          async def stream_agent_events(agent_id: str, session_id: str, input_data: dict):
              """Stream agent execution events via SSE"""
              
              async def generate_events():
                  factory = AgentFactory()
                  agent = factory.create_agent(agent_id)
                  
                  # VERIFIED: ADK InMemoryRunner pattern from documentation
                  runner = InMemoryRunner(agent, app_name="agent_engine")
                  
                  # VERIFIED: ADK run_async streaming pattern
                  async for event in runner.run_async(
                      user_id="system", 
                      session_id=session_id, 
                      new_message=input_data
                  ):
                      yield {
                          "event": "agent_event",
                          "data": json.dumps(event.model_dump() if hasattr(event, 'model_dump') else str(event))
                      }
              
              return EventSourceResponse(generate_events())
          
          @router.get("/sessions/{session_id}/events")
          async def stream_session_events(session_id: str):
              """Stream session state updates via SSE"""  # ADDED: Session streaming capability
              
              async def generate_events():
                  orchestrator = SessionOrchestrator()
                  # Stream session state changes
                  async for update in orchestrator.stream_session_updates(session_id):
                      yield {
                          "event": "session_update",
                          "data": json.dumps(update)
                      }
              
              return EventSourceResponse(generate_events())

      - path: "services/agent-engine/src/api/websocket/"
        purpose: "WebSocket implementation"
        content:
          - "__init__.py"
          - "connection_manager.py"
          - "handlers.py"
          - "messages.py"
          - "auth.py"
      
      - path: "services/agent-engine/src/api/websocket/connection_manager.py"
        purpose: "WebSocket connection management"
        exports:
          - "ConnectionManager: Manages WebSocket connections"
          - "Connection: Individual connection wrapper"
          - "ConnectionPool: Connection pooling"
        content_structure: |
          from typing import Dict, Set, List, Optional, Any
          from fastapi import WebSocket, WebSocketDisconnect
          from datetime import datetime
          import logging
          import asyncio
          import json
          from uuid import uuid4
          
          logger = logging.getLogger(__name__)
          
          class Connection:
              """WebSocket connection wrapper"""
              
              def __init__(self, websocket: WebSocket, client_id: str, user_id: Optional[str] = None):
                  self.websocket = websocket
                  self.client_id = client_id
                  self.user_id = user_id
                  self.session_id: Optional[str] = None
                  self.connected_at = datetime.now()
                  self.last_activity = datetime.now()
                  self.subscriptions: Set[str] = set()
                  self.metadata: Dict[str, Any] = {}
              
              async def send_json(self, data: Dict[str, Any]):
                  """Send JSON message to client"""
                  try:
                      await self.websocket.send_json(data)
                      self.last_activity = datetime.now()
                  except Exception as e:
                      logger.error(f"Failed to send to {self.client_id}: {e}")
                      raise
              
              async def send_text(self, text: str):
                  """Send text message to client"""
                  try:
                      await self.websocket.send_text(text)
                      self.last_activity = datetime.now()
                  except Exception as e:
                      logger.error(f"Failed to send to {self.client_id}: {e}")
                      raise
              
              async def receive_json(self) -> Dict[str, Any]:
                  """Receive JSON message from client"""
                  data = await self.websocket.receive_json()
                  self.last_activity = datetime.now()
                  return data
              
              def subscribe(self, channel: str):
                  """Subscribe to a channel"""
                  self.subscriptions.add(channel)
              
              def unsubscribe(self, channel: str):
                  """Unsubscribe from a channel"""
                  self.subscriptions.discard(channel)
              
              def is_subscribed(self, channel: str) -> bool:
                  """Check if subscribed to channel"""
                  return channel in self.subscriptions
          
          class ConnectionPool:
              """Pool of connections for a specific context"""
              
              def __init__(self, pool_id: str):
                  self.pool_id = pool_id
                  self.connections: Set[Connection] = set()
              
              def add(self, connection: Connection):
                  """Add connection to pool"""
                  self.connections.add(connection)
              
              def remove(self, connection: Connection):
                  """Remove connection from pool"""
                  self.connections.discard(connection)
              
              async def broadcast(self, message: Dict[str, Any], exclude: Optional[Connection] = None):
                  """Broadcast message to all connections in pool"""
                  tasks = []
                  for conn in self.connections:
                      if conn != exclude:
                          tasks.append(conn.send_json(message))
                  
                  if tasks:
                      results = await asyncio.gather(*tasks, return_exceptions=True)
                      # Log any failures
                      for i, result in enumerate(results):
                          if isinstance(result, Exception):
                              logger.error(f"Broadcast failed: {result}")
              
              def get_connection_count(self) -> int:
                  """Get number of connections in pool"""
                  return len(self.connections)
          
          class ConnectionManager:
              """Manages all WebSocket connections"""
              
              def __init__(self):
                  self.active_connections: Dict[str, Connection] = {}
                  self.user_connections: Dict[str, Set[str]] = {}  # user_id -> client_ids
                  self.session_connections: Dict[str, Set[str]] = {}  # session_id -> client_ids
                  self.pools: Dict[str, ConnectionPool] = {}
                  self.message_handlers: Dict[str, Any] = {}
              
              async def connect(self, websocket: WebSocket, client_id: Optional[str] = None) -> Connection:
                  """Accept and register new connection"""
                  await websocket.accept()
                  
                  if not client_id:
                      client_id = f"client_{uuid4().hex[:12]}"
                  
                  connection = Connection(websocket, client_id)
                  self.active_connections[client_id] = connection
                  
                  logger.info(f"Client {client_id} connected")
                  
                  # Send welcome message
                  await connection.send_json({
                      "type": "connection",
                      "status": "connected",
                      "client_id": client_id,
                      "timestamp": datetime.now().isoformat()
                  })
                  
                  return connection
              
              async def disconnect(self, client_id: str):
                  """Disconnect and cleanup connection"""
                  if client_id not in self.active_connections:
                      return
                  
                  connection = self.active_connections[client_id]
                  
                  # Remove from user connections
                  if connection.user_id:
                      if connection.user_id in self.user_connections:
                          self.user_connections[connection.user_id].discard(client_id)
                          if not self.user_connections[connection.user_id]:
                              del self.user_connections[connection.user_id]
                  
                  # Remove from session connections
                  if connection.session_id:
                      if connection.session_id in self.session_connections:
                          self.session_connections[connection.session_id].discard(client_id)
                          if not self.session_connections[connection.session_id]:
                              del self.session_connections[connection.session_id]
                  
                  # Remove from pools
                  for pool in self.pools.values():
                      pool.remove(connection)
                  
                  # Remove connection
                  del self.active_connections[client_id]
                  
                  logger.info(f"Client {client_id} disconnected")
              
              def set_user(self, client_id: str, user_id: str):
                  """Associate connection with user"""
                  if client_id not in self.active_connections:
                      return
                  
                  connection = self.active_connections[client_id]
                  connection.user_id = user_id
                  
                  if user_id not in self.user_connections:
                      self.user_connections[user_id] = set()
                  self.user_connections[user_id].add(client_id)
              
              def set_session(self, client_id: str, session_id: str):
                  """Associate connection with session"""
                  if client_id not in self.active_connections:
                      return
                  
                  connection = self.active_connections[client_id]
                  
                  # Remove from old session
                  if connection.session_id and connection.session_id in self.session_connections:
                      self.session_connections[connection.session_id].discard(client_id)
                  
                  # Add to new session
                  connection.session_id = session_id
                  if session_id not in self.session_connections:
                      self.session_connections[session_id] = set()
                  self.session_connections[session_id].add(client_id)
              
              async def send_to_client(self, client_id: str, message: Dict[str, Any]) -> bool:
                  """Send message to specific client"""
                  if client_id not in self.active_connections:
                      return False
                  
                  try:
                      await self.active_connections[client_id].send_json(message)
                      return True
                  except Exception as e:
                      logger.error(f"Failed to send to client {client_id}: {e}")
                      await self.disconnect(client_id)
                      return False
              
              async def send_to_user(self, user_id: str, message: Dict[str, Any]):
                  """Send message to all connections of a user"""
                  if user_id not in self.user_connections:
                      return
                  
                  tasks = []
                  for client_id in self.user_connections[user_id]:
                      tasks.append(self.send_to_client(client_id, message))
                  
                  await asyncio.gather(*tasks, return_exceptions=True)
              
              async def send_to_session(self, session_id: str, message: Dict[str, Any]):
                  """Send message to all connections in a session"""
                  if session_id not in self.session_connections:
                      return
                  
                  tasks = []
                  for client_id in self.session_connections[session_id]:
                      tasks.append(self.send_to_client(client_id, message))
                  
                  await asyncio.gather(*tasks, return_exceptions=True)
              
              async def broadcast(self, message: Dict[str, Any], channel: Optional[str] = None):
                  """Broadcast message to all or channel subscribers"""
                  tasks = []
                  
                  for connection in self.active_connections.values():
                      if channel is None or connection.is_subscribed(channel):
                          tasks.append(connection.send_json(message))
                  
                  if tasks:
                      await asyncio.gather(*tasks, return_exceptions=True)
              
              def get_pool(self, pool_id: str) -> ConnectionPool:
                  """Get or create connection pool"""
                  if pool_id not in self.pools:
                      self.pools[pool_id] = ConnectionPool(pool_id)
                  return self.pools[pool_id]
              
              def register_handler(self, message_type: str, handler):
                  """Register message handler"""
                  self.message_handlers[message_type] = handler
              
              async def handle_message(self, client_id: str, message: Dict[str, Any]):
                  """Route message to appropriate handler"""
                  message_type = message.get("type")
                  
                  if not message_type:
                      await self.send_to_client(client_id, {
                          "type": "error",
                          "error": "Missing message type"
                      })
                      return
                  
                  handler = self.message_handlers.get(message_type)
                  if not handler:
                      await self.send_to_client(client_id, {
                          "type": "error",
                          "error": f"Unknown message type: {message_type}"
                      })
                      return
                  
                  try:
                      connection = self.active_connections[client_id]
                      await handler(connection, message)
                  except Exception as e:
                      logger.error(f"Handler error for {message_type}: {e}")
                      await self.send_to_client(client_id, {
                          "type": "error",
                          "error": str(e)
                      })
              
              def get_stats(self) -> Dict:
                  """Get connection statistics"""
                  return {
                      "total_connections": len(self.active_connections),
                      "unique_users": len(self.user_connections),
                      "active_sessions": len(self.session_connections),
                      "pools": len(self.pools),
                      "connections_by_pool": {
                          pool_id: pool.get_connection_count()
                          for pool_id, pool in self.pools.items()
                      }
                  }
      
      - path: "services/agent-engine/src/api/websocket/handlers.py"
        purpose: "WebSocket message handlers with ADK integration"  # CORRECTED: Added ADK integration
        exports:
          - "handle_agent_execute"
          - "handle_session_message"
          - "handle_workflow_execute"
          - "handle_subscribe"
        content_structure: |
          from typing import Dict, Any
          import logging
          import asyncio
          
          from .connection_manager import Connection
          
          # VERIFIED: ADK imports from documentation
          from google.adk.runners import InMemoryRunner
          from google.adk.agents import BaseAgent
          
          from ...core.agent_factory import AgentFactory  # CORRECTED: Use existing components
          from ...core.session import SessionOrchestrator  # CORRECTED: Use existing session management
          from ...core.workflow import WorkflowEngine  # CORRECTED: Use existing workflow engine
          
          logger = logging.getLogger(__name__)
          
          async def handle_agent_execute(
              connection: Connection,
              message: Dict[str, Any],
              factory: AgentFactory,
              runner: InMemoryRunner  # VERIFIED: ADK InMemoryRunner
          ):
              """Handle agent execution request with ADK streaming"""  # CORRECTED: Added ADK streaming
              agent_spec = message.get("agent_spec")
              input_data = message.get("input_data", {})
              request_id = message.get("request_id")
              
              try:
                  # Create agent
                  agent = factory.create_agent(agent_spec)
                  
                  # CORRECTED: Use ADK runner.run_async pattern from MASTERPLAN
                  async for event in runner.run_async(
                      user_id=connection.user_id or "anonymous",
                      session_id=connection.session_id,
                      new_message=input_data
                  ):
                      await connection.send_json({
                          "type": "agent_event",
                          "request_id": request_id,
                          "event": event.model_dump() if hasattr(event, 'model_dump') else str(event)  # VERIFIED: ADK event handling
                      })
                  
                  # Send completion
                  await connection.send_json({
                      "type": "agent_complete",
                      "request_id": request_id,
                      "status": "success"
                  })
                  
              except Exception as e:
                  await connection.send_json({
                      "type": "agent_error",
                      "request_id": request_id,
                      "error": str(e)
                  })
          
          async def handle_session_message(
              connection: Connection,
              message: Dict[str, Any],
              orchestrator: SessionOrchestrator
          ):
              """Handle session-related messages with ADK session service"""  # CORRECTED: Added ADK reference
              action = message.get("action")
              session_id = message.get("session_id") or connection.session_id
              
              if action == "create":
                  # VERIFIED: ADK session creation pattern from documentation
                  session_id = await orchestrator.create_session({
                      "user_id": connection.user_id or "anonymous",
                      "app_name": message.get("app_name", "agent_engine")  # VERIFIED: ADK requires app_name
                  })
                  connection.session_id = session_id
                  
                  await connection.send_json({
                      "type": "session_created",
                      "session_id": session_id
                  })
              
              elif action == "update":
                  state_update = message.get("state")
                  success = await orchestrator.update_session(
                      session_id,
                      state_update=state_update
                  )
                  
                  await connection.send_json({
                      "type": "session_updated",
                      "session_id": session_id,
                      "success": success
                  })
              
              elif action == "get":
                  context = await orchestrator.get_session(session_id)
                  if context:
                      await connection.send_json({
                          "type": "session_data",
                          "session_id": session_id,
                          "state": context.state.model_dump(mode='json') if hasattr(context.state, 'model_dump') else str(context.state),
                          "metadata": context.metadata.model_dump(mode='json') if hasattr(context.metadata, 'model_dump') else str(context.metadata)
                      })
                  else:
                      await connection.send_json({
                          "type": "session_error",
                          "error": "Session not found"
                      })
          
          async def handle_workflow_execute(
              connection: Connection,
              message: Dict[str, Any],
              engine: WorkflowEngine
          ):
              """Handle workflow execution request with ADK streaming"""  # CORRECTED: Added ADK streaming
              template_name = message.get("template_name")
              input_data = message.get("input_data", {})
              request_id = message.get("request_id")
              
              try:
                  # CORRECTED: Use WorkflowEngine.execute_workflow_stream method from MASTERPLAN
                  async for event in engine.execute_workflow_stream(
                      template_name=template_name,
                      input_data=input_data,
                      session_id=connection.session_id
                  ):
                      await connection.send_json({
                          "type": "workflow_event",
                          "request_id": request_id,
                          "event": event
                      })
                  
                  # Send completion
                  await connection.send_json({
                      "type": "workflow_complete",
                      "request_id": request_id,
                      "status": "success"
                  })
                  
              except Exception as e:
                  await connection.send_json({
                      "type": "workflow_error",
                      "request_id": request_id,
                      "error": str(e)
                  })
          
          async def handle_subscribe(
              connection: Connection,
              message: Dict[str, Any]
          ):
              """Handle channel subscription"""
              action = message.get("action")
              channel = message.get("channel")
              
              if not channel:
                  await connection.send_json({
                      "type": "subscribe_error",
                      "error": "Channel required"
                  })
                  return
              
              if action == "subscribe":
                  connection.subscribe(channel)
                  await connection.send_json({
                      "type": "subscribed",
                      "channel": channel
                  })
              
              elif action == "unsubscribe":
                  connection.unsubscribe(channel)
                  await connection.send_json({
                      "type": "unsubscribed",
                      "channel": channel
                  })
      
      - path: "services/agent-engine/src/api/websocket/messages.py"
        purpose: "WebSocket message definitions"
        exports:
          - "WebSocketMessage: Base message class"
          - "AgentMessage: Agent-related messages"
          - "SessionMessage: Session-related messages"
          - "WorkflowMessage: Workflow-related messages"
      
      # ADDED: WebSocket endpoints integration
      - path: "services/agent-engine/src/api/websocket/endpoints.py"
        purpose: "FastAPI WebSocket endpoints"  # ADDED: Missing WebSocket endpoint integration
        exports:
          - "websocket_endpoint: Main WebSocket connection handler"
        content_structure: |
          from fastapi import APIRouter, WebSocket, WebSocketDisconnect
          from fastapi.responses import HTMLResponse
          import logging
          
          from .connection_manager import ConnectionManager
          from .handlers import handle_agent_execute, handle_session_message, handle_workflow_execute, handle_subscribe
          from ...core.agent_factory import AgentFactory
          from ...core.session import SessionOrchestrator
          from ...core.workflow import WorkflowEngine
          
          # VERIFIED: ADK imports
          from google.adk.runners import InMemoryRunner
          
          logger = logging.getLogger(__name__)
          router = APIRouter()
          
          # Global connection manager
          manager = ConnectionManager()
          
          @router.websocket("/ws")
          async def websocket_endpoint(websocket: WebSocket, client_id: str = None):
              """Main WebSocket connection handler"""
              connection = await manager.connect(websocket, client_id)
              
              # Initialize components
              factory = AgentFactory()
              orchestrator = SessionOrchestrator()
              workflow_engine = WorkflowEngine()
              
              try:
                  while True:
                      message = await connection.receive_json()
                      message_type = message.get("type")
                      
                      # Route messages to appropriate handlers
                      if message_type == "agent_execute":
                          runner = InMemoryRunner(app_name="websocket_agent")
                          await handle_agent_execute(connection, message, factory, runner)
                      elif message_type == "session":
                          await handle_session_message(connection, message, orchestrator)
                      elif message_type == "workflow_execute":
                          await handle_workflow_execute(connection, message, workflow_engine)
                      elif message_type == "subscribe":
                          await handle_subscribe(connection, message)
                      else:
                          await connection.send_json({
                              "type": "error",
                              "error": f"Unknown message type: {message_type}"
                          })
                          
              except WebSocketDisconnect:
                  await manager.disconnect(connection.client_id)
              except Exception as e:
                  logger.error(f"WebSocket error: {e}")
                  await manager.disconnect(connection.client_id)
      
      - path: "services/agent-engine/tests/test_websocket.py"
        purpose: "WebSocket tests"
        test_categories:
          - "Connection management"
          - "Message handling"
          - "Broadcasting"
          - "Session integration"
          - "Error scenarios"
          - "ADK integration"  # ADDED: ADK integration testing
    
    uses_from_previous:
      - source: "r6-t01"
        component: "API models and dependencies"
        usage: "Shared API infrastructure"
      - source: "r4-t04"
        component: "Event streaming"
        usage: "Stream events over WebSocket and SSE"  # CORRECTED: Added SSE
      # ADDED: ADK integration requirements
      - source: "r1-foundation"
        component: "ADK InMemoryRunner and session services"
        usage: "Core ADK streaming and session management"
    
  implementation_steps:
    # ADDED: SSE implementation step
    - step: "Implement Server-Sent Events (SSE) endpoints"
      implementation_notes: |
        - Primary streaming method per MASTERPLAN
        - GET /events/stream endpoint for real-time events
        - POST /workflows/{id}/stream for workflow streaming
        - Integration with ADK runner.run_async event iteration
        
    - step: "Create connection manager"
      implementation_notes: |
        - Connection tracking
        - User/session associations
        - Connection pools
        
    - step: "Implement message handlers with ADK integration"  # CORRECTED: Added ADK integration
      implementation_notes: |
        - Agent execution using ADK InMemoryRunner
        - Session management with ADK session services
        - Workflow execution with WorkflowEngine.execute_workflow_stream
        
    - step: "Add broadcasting"
      implementation_notes: |
        - Channel subscriptions
        - Targeted messaging
        - Event distribution
        
    - step: "Build WebSocket endpoints"
      implementation_notes: |
        - FastAPI integration
        - Authentication
        - Error handling
        
    # ADDED: Event-driven architecture step per MASTERPLAN
    - step: "Implement event-driven architecture"
      implementation_notes: |
        - Event publishing to external systems
        - Integration with existing SessionOrchestrator streaming patterns
        - Future-proofing for enterprise event publishing
        
  validation:
    commands:
      - description: "Test WebSocket connections"
        command: "cd services/agent-engine && pytest tests/test_websocket.py -v"
        expected: "All tests pass"
        
      - description: "Test with wscat"
        command: "wscat -c ws://localhost:8001/ws"
        expected: "Connection established"
        
      # ADDED: SSE testing per MASTERPLAN requirement
      - description: "Test SSE endpoints"
        command: "curl -N -H 'Accept: text/event-stream' http://localhost:8001/stream/workflows/test/events?session_id=test"
        expected: "Event stream established"
        
    success_criteria:
      - "Connection management working"
      - "Message routing functional"
      - "Broadcasting operational"
      - "Session integration complete"
      - "All tests pass"
      - "SSE endpoints functional"  # ADDED: SSE success criteria
      - "ADK streaming integration working"  # ADDED: ADK integration criteria
      
  dependencies:
    required_before:
      - task: "r6-t01"
        reason: "Need API infrastructure"
      - task: "r4-t04"
        reason: "Need event streaming"
    
    # ADDED: Additional dependencies for SSE
    additional_packages:
      - "sse-starlette"  # ADDED: SSE support for FastAPI
      - "aiofiles"  # ADDED: Async file operations if needed