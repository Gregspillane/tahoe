task:
  id: "r6-t03-graphql-interface"
  name: "Create GraphQL Interface for Specification-Driven Agent Orchestration"  # CORRECTED: Aligned with masterplan focus
  description: "Implement GraphQL API exposing specification-driven agent composition, workflow execution, tool registry, and model management capabilities"  # CORRECTED: Focused on specification system
  complexity: "medium"
  estimated_hours: 4  # CORRECTED: Increased due to broader scope
  
  context:
    why: "GraphQL provides flexible query interface for specification management, dynamic agent composition, and workflow orchestration while supporting advanced API consumers"  # CORRECTED: Aligned with core purpose
    architectural_role: "Alternative query interface for specification system and universal orchestration capabilities"  # CORRECTED: Specification-focused
    depends_on_tasks: ["r6-t01", "r6-t02"]
    enables_tasks: ["r6-t05"]
    references:
      masterplan: "@MASTERPLAN.md#api-architecture"  # CORRECTED: Actual section
      architecture: "@memory-bank/architecture.md#graphql-design"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/api/graphql/"
        purpose: "GraphQL implementation for specification-driven orchestration"  # CORRECTED: Clarified purpose
        content:
          - "__init__.py"
          - "schema.py"
          - "types.py"
          - "resolvers.py"  # CORRECTED: Reorganized order
          - "mutations.py"
          - "subscriptions.py"
          - "specification_resolvers.py"  # ADDED: From masterplan - spec system integration
          - "composition_resolvers.py"    # ADDED: From masterplan - agent composition
      
      - path: "services/agent-engine/src/api/graphql/schema.py"
        purpose: "GraphQL schema definition with specification system integration"  # CORRECTED: Updated purpose
        exports:
          - "schema: GraphQL schema object"
          - "Query: Root query type"
          - "Mutation: Root mutation type"
          - "Subscription: Root subscription type"
        content_structure: |
          import strawberry
          from typing import List, Optional, Dict, Any
          from datetime import datetime
          
          from .types import (
              # ADDED: Specification types from masterplan
              AgentSpecification,
              WorkflowTemplate,
              ToolSpecification,
              ModelConfiguration,
              # Core entities
              Agent,
              Session,
              Workflow,
              AgentExecution,
              WorkflowExecution,
              Tool,  # ADDED: Tool type
              Model   # ADDED: Model type
          )
          from .resolvers import (
              AgentResolver,
              SessionResolver,
              WorkflowResolver
          )
          from .specification_resolvers import (  # ADDED: From masterplan
              SpecificationResolver
          )
          from .composition_resolvers import (  # ADDED: From masterplan  
              CompositionResolver
          )
          from .mutations import (
              AgentMutations,
              SessionMutations,
              WorkflowMutations,
              SpecificationMutations  # ADDED: Spec mutations
          )
          from .subscriptions import (
              AgentSubscriptions,
              SessionSubscriptions,
              WorkflowSubscriptions
          )
          
          @strawberry.type
          class Query:
              """Root query type for specification-driven orchestration"""  # CORRECTED: Updated description
              
              # ADDED: Specification system queries from masterplan
              @strawberry.field
              async def agent_specifications(
                  self,
                  tags: Optional[List[str]] = None,
                  agent_type: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[AgentSpecification]:
                  """List available agent specifications"""
                  return await SpecificationResolver.list_agent_specs(
                      tags=tags,
                      agent_type=agent_type,
                      limit=limit,
                      offset=offset
                  )
              
              @strawberry.field
              async def workflow_templates(
                  self,
                  workflow_type: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[WorkflowTemplate]:
                  """List available workflow templates"""
                  return await SpecificationResolver.list_workflow_templates(
                      workflow_type=workflow_type,
                      limit=limit,
                      offset=offset
                  )
              
              @strawberry.field
              async def tool_specifications(
                  self,
                  category: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[ToolSpecification]:
                  """List available tool specifications"""
                  return await SpecificationResolver.list_tool_specs(
                      category=category,
                      limit=limit,
                      offset=offset
                  )
              
              @strawberry.field
              async def model_configurations(self) -> List[ModelConfiguration]:
                  """List available model configurations"""
                  return await SpecificationResolver.list_model_configs()
              
              # Agent composition queries
              @strawberry.field
              async def compose_agent_preview(
                  self,
                  spec_name: str,
                  context: Optional[strawberry.scalars.JSON] = None
              ) -> Agent:
                  """Preview agent composition from specification"""
                  return await CompositionResolver.preview_agent_composition(
                      spec_name=spec_name,
                      context=context
                  )
              
              # Runtime agent queries
              @strawberry.field
              async def agent(self, id: str) -> Optional[Agent]:
                  """Get runtime agent instance by ID"""
                  return await AgentResolver.get_agent(id)
              
              @strawberry.field
              async def agents(
                  self,
                  spec_name: Optional[str] = None,  # ADDED: Filter by specification
                  status: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Agent]:
                  """List runtime agent instances with filters"""
                  return await AgentResolver.list_agents(
                      spec_name=spec_name,  # CORRECTED: Spec-based filtering
                      status=status,
                      limit=limit,
                      offset=offset
                  )
              
              # Session queries (ADK Session Service integration)
              @strawberry.field
              async def session(self, id: str) -> Optional[Session]:
                  """Get ADK session by ID"""  # VERIFIED: ADK session service pattern
                  return await SessionResolver.get_session(id)
              
              @strawberry.field
              async def sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True,
                  backend_type: Optional[str] = None,  # ADDED: From masterplan - multi-backend support
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Session]:
                  """List ADK sessions with filters"""  # VERIFIED: ADK session service pattern
                  return await SessionResolver.list_sessions(
                      user_id=user_id,
                      app_name=app_name,
                      active_only=active_only,
                      backend_type=backend_type,  # ADDED: Multi-backend filtering
                      limit=limit,
                      offset=offset
                  )
              
              # Workflow execution queries (ADK Runner integration)
              @strawberry.field
              async def workflow_execution(self, id: str) -> Optional[WorkflowExecution]:
                  """Get workflow execution by ID"""  # VERIFIED: ADK InMemoryRunner pattern
                  return await WorkflowResolver.get_execution(id)
              
              @strawberry.field
              async def workflow_executions(
                  self,
                  template_name: Optional[str] = None,  # CORRECTED: Template-based filtering
                  session_id: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[WorkflowExecution]:
                  """List workflow executions with filters"""
                  return await WorkflowResolver.list_executions(
                      template_name=template_name,  # CORRECTED: From masterplan
                      session_id=session_id,
                      status=status,
                      limit=limit,
                      offset=offset
                  )
              
              # ADDED: Tool registry queries from masterplan
              @strawberry.field
              async def registered_tools(
                  self,
                  category: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Tool]:
                  """List registered tools from tool registry"""
                  return await SpecificationResolver.list_registered_tools(
                      category=category,
                      limit=limit,
                      offset=offset
                  )
              
              # ADDED: Model management queries from masterplan
              @strawberry.field
              async def model_health_status(self) -> List[Model]:
                  """Check health status of configured models"""
                  return await SpecificationResolver.get_model_health()
              
              # Execution queries
              @strawberry.field
              async def agent_executions(
                  self,
                  agent_id: Optional[str] = None,
                  session_id: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 50,
                  offset: int = 0
              ) -> List[AgentExecution]:
                  """List agent executions"""
                  return await AgentResolver.list_executions(
                      agent_id=agent_id,
                      session_id=session_id,
                      status=status,
                      limit=limit,
                      offset=offset
                  )
              
              @strawberry.field
              async def workflow_executions(
                  self,
                  workflow_id: Optional[str] = None,
                  session_id: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 50,
                  offset: int = 0
              ) -> List[WorkflowExecution]:
                  """List workflow executions"""
                  return await WorkflowResolver.list_executions(
                      workflow_id=workflow_id,
                      session_id=session_id,
                      status=status,
                      limit=limit,
                      offset=offset
                  )
              
              # Aggregation queries
              @strawberry.field
              async def agent_stats(self) -> Dict[str, Any]:
                  """Get agent statistics"""
                  return await AgentResolver.get_stats()
              
              @strawberry.field
              async def session_stats(self) -> Dict[str, Any]:
                  """Get session statistics"""
                  return await SessionResolver.get_stats()
              
              @strawberry.field
              async def workflow_stats(self) -> Dict[str, Any]:
                  """Get workflow statistics"""
                  return await WorkflowResolver.get_stats()
          
          @strawberry.type
          class Mutation:
              """Root mutation type for specification-driven operations"""  # CORRECTED: Updated description
              
              # ADDED: Specification management mutations from masterplan
              @strawberry.field
              async def create_agent_specification(
                  self,
                  spec_data: strawberry.scalars.JSON
              ) -> AgentSpecification:
                  """Create new agent specification"""
                  return await SpecificationMutations.create_agent_spec(
                      spec_data=spec_data
                  )
              
              @strawberry.field
              async def update_agent_specification(
                  self,
                  spec_name: str,
                  spec_data: strawberry.scalars.JSON
              ) -> AgentSpecification:
                  """Update agent specification"""
                  return await SpecificationMutations.update_agent_spec(
                      spec_name=spec_name,
                      spec_data=spec_data
                  )
              
              @strawberry.field
              async def validate_specification(
                  self,
                  spec_type: str,
                  spec_data: strawberry.scalars.JSON
              ) -> bool:
                  """Validate specification format"""
                  return await SpecificationMutations.validate_spec(
                      spec_type=spec_type,
                      spec_data=spec_data
                  )
              
              # Agent composition mutations (ADK AgentFactory integration)
              @strawberry.field
              async def compose_agent_from_spec(
                  self,
                  spec_name: str,
                  context: Optional[strawberry.scalars.JSON] = None,
                  session_config: Optional[strawberry.scalars.JSON] = None
              ) -> Agent:
                  """Compose agent from specification using ADK"""  # VERIFIED: ADK pattern
                  return await CompositionMutations.compose_agent(
                      spec_name=spec_name,
                      context=context,
                      session_config=session_config
                  )
              
              @strawberry.field
              async def execute_agent_composition(
                  self,
                  spec_name: str,
                  input_data: strawberry.scalars.JSON,
                  session_id: Optional[str] = None,
                  context: Optional[strawberry.scalars.JSON] = None
              ) -> AgentExecution:
                  """Execute agent composed from specification"""  # VERIFIED: ADK InMemoryRunner pattern
                  return await CompositionMutations.execute_agent_from_spec(
                      spec_name=spec_name,
                      input_data=input_data,
                      session_id=session_id,
                      context=context
                  )
              
              @strawberry.field
              async def delete_agent(self, agent_id: str) -> bool:
                  """Delete an agent"""
                  return await AgentMutations.delete_agent(agent_id)
              
              # Session mutations
              @strawberry.field
              async def create_session(
                  self,
                  user_id: str,
                  app_name: str,
                  config: Optional[strawberry.scalars.JSON] = None
              ) -> Session:
                  """Create new session"""
                  return await SessionMutations.create_session(
                      user_id=user_id,
                      app_name=app_name,
                      config=config
                  )
              
              @strawberry.field
              async def update_session(
                  self,
                  session_id: str,
                  state: Optional[strawberry.scalars.JSON] = None,
                  metadata: Optional[strawberry.scalars.JSON] = None
              ) -> Session:
                  """Update session"""
                  return await SessionMutations.update_session(
                      session_id=session_id,
                      state=state,
                      metadata=metadata
                  )
              
              @strawberry.field
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: Optional[str] = None
              ) -> Session:
                  """Fork a session"""
                  return await SessionMutations.fork_session(
                      source_session_id=source_session_id,
                      new_session_id=new_session_id
                  )
              
              @strawberry.field
              async def delete_session(self, session_id: str) -> bool:
                  """Delete a session"""
                  return await SessionMutations.delete_session(session_id)
              
              # Workflow mutations
              @strawberry.field
              async def create_workflow(
                  self,
                  name: str,
                  specification: strawberry.scalars.JSON
              ) -> Workflow:
                  """Create new workflow"""
                  return await WorkflowMutations.create_workflow(
                      name=name,
                      specification=specification
                  )
              
              @strawberry.field
              async def execute_workflow(
                  self,
                  workflow_id: str,
                  input_data: strawberry.scalars.JSON,
                  session_id: Optional[str] = None
              ) -> WorkflowExecution:
                  """Execute a workflow"""
                  return await WorkflowMutations.execute_workflow(
                      workflow_id=workflow_id,
                      input_data=input_data,
                      session_id=session_id
                  )
          
          @strawberry.type
          class Subscription:
              """Root subscription type"""
              
              @strawberry.subscription
              async def agent_events(
                  self,
                  agent_id: Optional[str] = None,
                  session_id: Optional[str] = None
              ):
                  """Subscribe to agent events"""
                  async for event in AgentSubscriptions.agent_events(
                      agent_id=agent_id,
                      session_id=session_id
                  ):
                      yield event
              
              @strawberry.subscription
              async def session_updates(
                  self,
                  session_id: Optional[str] = None,
                  user_id: Optional[str] = None
              ):
                  """Subscribe to session updates"""
                  async for update in SessionSubscriptions.session_updates(
                      session_id=session_id,
                      user_id=user_id
                  ):
                      yield update
              
              @strawberry.subscription
              async def workflow_progress(
                  self,
                  workflow_id: Optional[str] = None,
                  session_id: Optional[str] = None
              ):
                  """Subscribe to workflow progress"""
                  async for progress in WorkflowSubscriptions.workflow_progress(
                      workflow_id=workflow_id,
                      session_id=session_id
                  ):
                      yield progress
          
          # Create the schema
          schema = strawberry.Schema(
              query=Query,
              mutation=Mutation,
              subscription=Subscription
          )
      
      - path: "services/agent-engine/src/api/graphql/types.py"
        purpose: "GraphQL type definitions for specification-driven orchestration"  # CORRECTED: Updated purpose
        exports:
          # ADDED: Specification types from masterplan
          - "AgentSpecification: Agent specification type"
          - "WorkflowTemplate: Workflow template type"
          - "ToolSpecification: Tool specification type"
          - "ModelConfiguration: Model configuration type"
          # Runtime types
          - "Agent: Runtime agent GraphQL type"
          - "Session: ADK session GraphQL type"
          - "Workflow: Workflow execution type"
          - "AgentExecution: Agent execution type"
          - "WorkflowExecution: Workflow execution type"
          - "Tool: Tool registry type"
          - "Model: Model health type"
        content_structure: |
          import strawberry
          from typing import List, Optional, Dict, Any
          from datetime import datetime
          from enum import Enum
          
          # VERIFIED: ADK agent types from documentation
          @strawberry.enum
          class AgentType(Enum):
              LLM = "llm"              # VERIFIED: LlmAgent from ADK docs
              SEQUENTIAL = "sequential"  # VERIFIED: SequentialAgent from ADK docs  
              PARALLEL = "parallel"     # VERIFIED: ParallelAgent from ADK docs
              LOOP = "loop"            # VERIFIED: LoopAgent from ADK docs
              CUSTOM = "custom"        # VERIFIED: Custom BaseAgent from ADK docs
          
          @strawberry.enum
          class AgentStatus(Enum):
              READY = "ready"
              RUNNING = "running"
              ERROR = "error"
              DISABLED = "disabled"
          
          @strawberry.enum
          class ExecutionStatus(Enum):
              PENDING = "pending"
              RUNNING = "running"
              COMPLETED = "completed"
              FAILED = "failed"
              CANCELLED = "cancelled"
          
          @strawberry.enum
          class WorkflowType(Enum):  # ADDED: From masterplan
              SEQUENTIAL = "sequential"
              PARALLEL = "parallel"
              CONDITIONAL = "conditional"
              CUSTOM = "custom"
          
          @strawberry.enum
          class ModelProvider(Enum):  # ADDED: From masterplan
              GOOGLE = "google"
              OPENAI = "openai"
              ANTHROPIC = "anthropic"
              OLLAMA = "ollama"
          
          # ADDED: Specification types from masterplan
          @strawberry.type
          class AgentSpecification:
              """Agent specification from specs/ directory"""
              api_version: str
              kind: str
              metadata: strawberry.scalars.JSON
              spec: strawberry.scalars.JSON
              created_at: datetime
              updated_at: Optional[datetime] = None
              file_path: str
              
              @strawberry.field
              async def preview_composition(
                  self,
                  context: Optional[strawberry.scalars.JSON] = None
              ) -> "Agent":
                  """Preview agent composition from this specification"""
                  from .composition_resolvers import CompositionResolver
                  return await CompositionResolver.preview_from_spec(self, context)
          
          @strawberry.type
          class WorkflowTemplate:
              """Workflow template from specs/ directory"""
              api_version: str
              kind: str
              metadata: strawberry.scalars.JSON
              spec: strawberry.scalars.JSON
              workflow_type: WorkflowType
              created_at: datetime
              updated_at: Optional[datetime] = None
              file_path: str
          
          @strawberry.type
          class ToolSpecification:
              """Tool specification from specs/ directory"""
              api_version: str
              kind: str
              metadata: strawberry.scalars.JSON
              spec: strawberry.scalars.JSON
              categories: List[str]
              dependencies: List[str]
              created_at: datetime
              updated_at: Optional[datetime] = None
              file_path: str
          
          @strawberry.type
          class ModelConfiguration:
              """Model configuration from specs/ directory"""
              api_version: str
              kind: str
              metadata: strawberry.scalars.JSON
              spec: strawberry.scalars.JSON
              primary_model: str
              fallback_models: List[str]
              created_at: datetime
              updated_at: Optional[datetime] = None
              file_path: str
          
          @strawberry.type
          class Tool:
              """Runtime tool from tool registry"""
              name: str
              description: str
              categories: List[str]
              input_schema: strawberry.scalars.JSON
              output_schema: strawberry.scalars.JSON
              created_at: datetime
              usage_count: int
          
          @strawberry.type
          class Model:
              """Model health and configuration status"""
              name: str
              provider: ModelProvider
              is_healthy: bool
              response_time_ms: Optional[float] = None
              error_message: Optional[str] = None
              last_checked: datetime
          
          @strawberry.type
          class Agent:
              """Runtime agent instance (ADK-composed)"""  # CORRECTED: Clarified as runtime instance
              id: str
              name: str
              type: AgentType
              status: AgentStatus
              created_at: datetime
              updated_at: Optional[datetime] = None
              specification_name: Optional[str] = None  # ADDED: Link to spec
              session_id: Optional[str] = None  # ADDED: ADK session reference
              metadata: strawberry.scalars.JSON
              tags: List[str]
              
              @strawberry.field
              async def executions(
                  self,
                  limit: int = 10,
                  offset: int = 0
              ) -> List["AgentExecution"]:
                  """Get agent executions"""
                  from .resolvers import AgentResolver
                  return await AgentResolver.get_agent_executions(
                      self.id,
                      limit=limit,
                      offset=offset
                  )
          
          @strawberry.type
          class Session:
              """ADK Session GraphQL type"""  # VERIFIED: ADK session service pattern
              id: str
              user_id: str
              app_name: str
              created_at: datetime
              updated_at: datetime
              is_active: bool
              backend_type: str  # ADDED: From masterplan - memory, redis, vertex
              parent_session_id: Optional[str] = None  # ADDED: Session forking support
              state: strawberry.scalars.JSON  # VERIFIED: ADK session state
              conversation_history: List[strawberry.scalars.JSON]  # ADDED: ADK conversation events
              metadata: strawberry.scalars.JSON
              tags: List[str]
              
              @strawberry.field
              async def child_sessions(self) -> List["Session"]:
                  """Get child sessions (forks)"""
                  from .resolvers import SessionResolver
                  return await SessionResolver.get_child_sessions(self.id)
              
              @strawberry.field
              async def agent_executions(
                  self,
                  limit: int = 10,
                  offset: int = 0
              ) -> List["AgentExecution"]:
                  """Get executions in this session"""
                  from .resolvers import AgentResolver
                  return await AgentResolver.list_executions(
                      session_id=self.id,
                      limit=limit,
                      offset=offset
                  )
          
          @strawberry.type
          class Workflow:
              """Workflow GraphQL type"""
              id: str
              name: str
              created_at: datetime
              updated_at: Optional[datetime] = None
              specification: strawberry.scalars.JSON
              metadata: strawberry.scalars.JSON
              tags: List[str]
              
              @strawberry.field
              async def executions(
                  self,
                  limit: int = 10,
                  offset: int = 0
              ) -> List["WorkflowExecution"]:
                  """Get workflow executions"""
                  from .resolvers import WorkflowResolver
                  return await WorkflowResolver.get_workflow_executions(
                      self.id,
                      limit=limit,
                      offset=offset
                  )
          
          @strawberry.type
          class AgentExecution:
              """Agent execution GraphQL type"""
              id: str
              agent_id: str
              session_id: Optional[str] = None
              status: ExecutionStatus
              started_at: datetime
              completed_at: Optional[datetime] = None
              input_data: strawberry.scalars.JSON
              result: Optional[strawberry.scalars.JSON] = None
              errors: List[str]
              metadata: strawberry.scalars.JSON
              
              @strawberry.field
              async def agent(self) -> Optional[Agent]:
                  """Get the agent for this execution"""
                  from .resolvers import AgentResolver
                  return await AgentResolver.get_agent(self.agent_id)
              
              @strawberry.field
              async def session(self) -> Optional[Session]:
                  """Get the session for this execution"""
                  if not self.session_id:
                      return None
                  from .resolvers import SessionResolver
                  return await SessionResolver.get_session(self.session_id)
          
          @strawberry.type
          class WorkflowExecution:
              """Workflow execution GraphQL type"""
              id: str
              workflow_id: str
              session_id: Optional[str] = None
              status: ExecutionStatus
              started_at: datetime
              completed_at: Optional[datetime] = None
              current_step: Optional[str] = None
              progress: float
              input_data: strawberry.scalars.JSON
              result: Optional[strawberry.scalars.JSON] = None
              errors: List[str]
              metadata: strawberry.scalars.JSON
              
              @strawberry.field
              async def workflow(self) -> Optional[Workflow]:
                  """Get the workflow for this execution"""
                  from .resolvers import WorkflowResolver
                  return await WorkflowResolver.get_workflow(self.workflow_id)
      
      - path: "services/agent-engine/src/api/graphql/resolvers.py"
        purpose: "GraphQL resolvers for runtime entities"  # CORRECTED: Clarified scope
        exports:
          - "AgentResolver"
          - "SessionResolver" 
          - "WorkflowResolver"
        content_structure: |
          from typing import List, Optional, Dict, Any
          import logging
          
          from .types import Agent, Session, Workflow, AgentExecution, WorkflowExecution
          # VERIFIED: ADK integration imports from masterplan
          from ...core.composition import UniversalAgentFactory  # CORRECTED: From masterplan
          from ...core.session import SessionOrchestrator
          from ...core.workflow import WorkflowEngine
          
          logger = logging.getLogger(__name__)
          
          class AgentResolver:
              """Agent GraphQL resolvers"""
              
              @staticmethod
              async def get_agent(agent_id: str) -> Optional[Agent]:
                  """Get agent by ID"""
                  # Implementation would fetch from agent store
                  pass
              
              @staticmethod
              async def list_agents(
                  type: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Agent]:
                  """List agents with filters"""
                  # Implementation would query agent store
                  pass
              
              @staticmethod
              async def list_executions(
                  agent_id: Optional[str] = None,
                  session_id: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 50,
                  offset: int = 0
              ) -> List[AgentExecution]:
                  """List agent executions"""
                  # Implementation would query execution store
                  pass
              
              @staticmethod
              async def get_stats() -> Dict[str, Any]:
                  """Get agent statistics"""
                  # Implementation would aggregate agent metrics
                  return {
                      "total_agents": 0,
                      "active_agents": 0,
                      "total_executions": 0,
                      "executions_today": 0
                  }
          
          class SessionResolver:
              """Session GraphQL resolvers"""
              
              @staticmethod
              async def get_session(session_id: str) -> Optional[Session]:
                  """Get session by ID"""
                  # Implementation would use SessionOrchestrator
                  pass
              
              @staticmethod
              async def list_sessions(
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Session]:
                  """List sessions with filters"""
                  # Implementation would query session backend
                  pass
              
              @staticmethod
              async def get_child_sessions(session_id: str) -> List[Session]:
                  """Get child sessions (forks)"""
                  # Implementation would find sessions with parent_session_id
                  pass
              
              @staticmethod
              async def get_stats() -> Dict[str, Any]:
                  """Get session statistics"""
                  return {
                      "total_sessions": 0,
                      "active_sessions": 0,
                      "sessions_today": 0,
                      "average_session_duration": 0
                  }
          
          class WorkflowResolver:
              """Workflow GraphQL resolvers"""
              
              @staticmethod
              async def get_workflow(workflow_id: str) -> Optional[Workflow]:
                  """Get workflow by ID"""
                  # Implementation would use WorkflowEngine
                  pass
              
              @staticmethod
              async def list_workflows(
                  status: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Workflow]:
                  """List workflows with filters"""
                  # Implementation would query workflow store
                  pass
              
              @staticmethod
              async def list_executions(
                  workflow_id: Optional[str] = None,
                  session_id: Optional[str] = None,
                  status: Optional[str] = None,
                  limit: int = 50,
                  offset: int = 0
              ) -> List[WorkflowExecution]:
                  """List workflow executions"""
                  # Implementation would query execution store
                  pass
              
              @staticmethod
              async def get_stats() -> Dict[str, Any]:
                  """Get workflow statistics"""
                  return {
                      "total_workflows": 0,
                      "active_workflows": 0,
                      "total_executions": 0,
                      "executions_today": 0
                  }
      
      # ADDED: Specification resolver from masterplan
      - path: "services/agent-engine/src/api/graphql/specification_resolvers.py"
        purpose: "GraphQL resolvers for specification system"
        exports:
          - "SpecificationResolver"
        content_structure: |
          from typing import List, Optional, Dict, Any
          import logging
          from pathlib import Path
          
          from .types import (
              AgentSpecification, 
              WorkflowTemplate, 
              ToolSpecification, 
              ModelConfiguration,
              Tool,
              Model
          )
          # VERIFIED: Core service imports from masterplan
          from ...services.configuration import ConfigurationLoader  # From masterplan
          from ...core.tools import ToolRegistry  # From masterplan  
          from ...core.models import ModelAbstraction  # From masterplan
          
          logger = logging.getLogger(__name__)
          
          class SpecificationResolver:
              """Specification system GraphQL resolvers"""
              
              @staticmethod
              async def list_agent_specs(
                  tags: Optional[List[str]] = None,
                  agent_type: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[AgentSpecification]:
                  """List agent specifications from specs/agents/"""
                  # Implementation would scan specs/agents/ directory
                  pass
              
              @staticmethod
              async def list_workflow_templates(
                  workflow_type: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[WorkflowTemplate]:
                  """List workflow templates from specs/workflows/"""
                  # Implementation would scan specs/workflows/ directory
                  pass
              
              @staticmethod
              async def list_tool_specs(
                  category: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[ToolSpecification]:
                  """List tool specifications from specs/tools/"""
                  # Implementation would scan specs/tools/ directory
                  pass
              
              @staticmethod
              async def list_model_configs() -> List[ModelConfiguration]:
                  """List model configurations from specs/models/"""
                  # Implementation would scan specs/models/ directory
                  pass
              
              @staticmethod
              async def list_registered_tools(
                  category: Optional[str] = None,
                  limit: int = 100,
                  offset: int = 0
              ) -> List[Tool]:
                  """List registered tools from tool registry"""
                  # Implementation would query ToolRegistry
                  pass
              
              @staticmethod
              async def get_model_health() -> List[Model]:
                  """Get model health status"""
                  # Implementation would check model availability
                  pass
      
      # ADDED: Composition resolver from masterplan
      - path: "services/agent-engine/src/api/graphql/composition_resolvers.py"
        purpose: "GraphQL resolvers for agent composition"
        exports:
          - "CompositionResolver"
        content_structure: |
          from typing import List, Optional, Dict, Any
          import logging
          
          from .types import Agent, AgentExecution, AgentSpecification
          # VERIFIED: ADK integration from masterplan
          from ...core.composition import UniversalAgentFactory  # From masterplan
          from ...core.workflow import WorkflowEngine  # From masterplan
          from google.adk.runners import InMemoryRunner  # VERIFIED: ADK runner
          
          logger = logging.getLogger(__name__)
          
          class CompositionResolver:
              """Agent composition GraphQL resolvers"""
              
              @staticmethod
              async def preview_agent_composition(
                  spec_name: str,
                  context: Optional[Dict[str, Any]] = None
              ) -> Agent:
                  """Preview agent composition from specification"""
                  # Implementation would use UniversalAgentFactory
                  # to build agent from spec without executing
                  pass
              
              @staticmethod
              async def preview_from_spec(
                  spec: AgentSpecification,
                  context: Optional[Dict[str, Any]] = None
              ) -> Agent:
                  """Preview agent composition from specification object"""
                  # Implementation would compose agent preview
                  pass
      
      - path: "services/agent-engine/tests/test_graphql.py"
        purpose: "GraphQL tests"
        test_categories:
          - "Query resolution"
          - "Mutations"
          - "Subscriptions"
          - "Type relationships"
          - "Error handling"
    
    uses_from_previous:
      - source: "r6-t01"
        component: "API infrastructure"
        usage: "Shared API foundation"
      - source: "r6-t02"
        component: "WebSocket support"
        usage: "GraphQL subscriptions"
    
  implementation_steps:
    - step: "Define specification-aware GraphQL types"  # CORRECTED: Spec-focused
      implementation_notes: |
        - VERIFIED: Strawberry types with @strawberry.type decorator
        - ADK-compatible enums (LLM, SEQUENTIAL, PARALLEL, LOOP, CUSTOM)
        - Specification types (AgentSpecification, WorkflowTemplate, ToolSpecification, ModelConfiguration)
        - Runtime types with specification links
        - Field relationships between specs and runtime instances
        
    - step: "Create unified schema with specification integration"  # CORRECTED: Unified approach
      implementation_notes: |
        - Root Query type with specification queries
        - Specification management mutations
        - Agent composition queries and mutations
        - ADK session and execution subscriptions
        - Model and tool registry integration
        
    - step: "Implement specification system resolvers"  # ADDED: From masterplan
      implementation_notes: |
        - SpecificationResolver for specs/ directory scanning
        - ConfigurationLoader integration for YAML/JSON parsing
        - Tool registry queries for runtime tools
        - Model health checking and configuration status
        
    - step: "Implement composition resolvers"  # ADDED: From masterplan
      implementation_notes: |
        - VERIFIED: UniversalAgentFactory integration from masterplan
        - VERIFIED: ADK InMemoryRunner for execution
        - Agent preview composition without execution
        - Context injection for dynamic agent building
        
    - step: "Add specification management mutations"  # CORRECTED: Spec-focused
      implementation_notes: |
        - Specification CRUD operations
        - YAML/JSON validation using services.validation
        - Agent composition from specifications
        - ADK session creation with composition
        - Error handling for invalid specifications
        
    - step: "Build real-time orchestration subscriptions"  # CORRECTED: Orchestration-focused
      implementation_notes: |
        - VERIFIED: Real-time agent execution events
        - ADK session state change notifications
        - Workflow progress streaming
        - Tool execution monitoring
        - Model health status updates
        
  validation:
    commands:
      - description: "Test GraphQL schema with specification types"  # CORRECTED: Specification focus
        command: "cd services/agent-engine && pytest tests/test_graphql.py::test_specification_types -v"
        expected: "Specification types properly defined"
        
      - description: "Test agent composition queries"  # ADDED: Composition testing
        command: "cd services/agent-engine && pytest tests/test_graphql.py::test_composition_queries -v"
        expected: "Agent composition queries working"
        
      - description: "Query specification system via GraphQL"  # CORRECTED: Spec-focused query
        command: "curl -X POST http://localhost:8001/graphql -H 'Content-Type: application/json' -d '{\"query\": \"{ agentSpecifications { metadata spec } }\"}'"
        expected: "Agent specifications returned from specs/ directory"
        
      - description: "Test tool registry integration"  # ADDED: Tool registry testing
        command: "curl -X POST http://localhost:8001/graphql -H 'Content-Type: application/json' -d '{\"query\": \"{ registeredTools { name categories } }\"}'"
        expected: "Registered tools returned from tool registry"
        
    success_criteria:
      - "Specification types properly defined and accessible"  # CORRECTED: Spec focus
      - "Agent composition queries working with UniversalAgentFactory"  # ADDED: Composition
      - "Tool registry integration functional"  # ADDED: Tool registry
      - "Model configuration queries operational"  # ADDED: Model management
      - "ADK session integration working correctly"  # VERIFIED: ADK focus
      - "All specification-related tests pass"  # CORRECTED: Spec tests
      
  dependencies:
    required_before:
      - task: "r6-t01"
        reason: "Need REST API foundation"
      - task: "r6-t02"
        reason: "Need WebSocket for subscriptions"