task:
  id: "r1-t03-specification-system"
  name: "Build Specification Parser and Validator"
  description: "Create YAML/JSON specification system for agents, workflows, and tools"
  complexity: "complex"
  estimated_hours: 3
  
  context:
    why: "Enable configuration-driven agent composition without code changes"
    architectural_role: "Core system for defining all agents and workflows via specifications"
    depends_on_tasks: ["r1-t01"]
    enables_tasks: ["r2-t01", "r2-t02", "r4-t01"]
    references:
      masterplan: "@MASTERPLAN.md#configuration-storage"
      adk_docs: 
        - "https://google.github.io/adk-docs/agents#configuration"
        - "https://google.github.io/adk-docs/tools#specification"
      verification_notes: "Specification format designed to map directly to ADK component parameters"
    
  adk_components:
    imports_needed:
      - "import yaml"
      - "import json"
      - "from pydantic import BaseModel, Field, validator"
      - "from typing import Dict, Any, List, Optional, Union"
      - "from enum import Enum"
    verified_patterns:
      - pattern: "Map specifications to ADK agent parameters"
        doc_ref: "https://google.github.io/adk-docs/agents#parameters"
      - pattern: "Validate against ADK requirements"
        doc_ref: "https://google.github.io/adk-docs/agents#validation"
    avoid_antipatterns:
      - "Don't create custom agent configuration formats"
      - "Don't bypass ADK parameter validation"
      - "Don't hardcode specification paths"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/specifications.py"
        purpose: "Specification models and parser"
        exports:
          - "class SpecificationParser"
          - "class SpecificationValidator"
          - "class AgentSpec"
          - "class WorkflowSpec"
          - "class ToolSpec"
      - path: "services/agent-engine/src/models/specifications.py"
        purpose: "Pydantic models for specifications"
        exports:
          - "class AgentSpecification"
          - "class WorkflowTemplate"
          - "class ToolSpecification"
          - "class ModelConfiguration"
      - path: "services/agent-engine/src/utils/parser.py"
        purpose: "YAML/JSON parsing utilities"
        exports:
          - "load_yaml_spec()"
          - "load_json_spec()"
          - "validate_spec_format()"
      - path: "services/agent-engine/src/utils/validator.py"
        purpose: "Specification validation"
        exports:
          - "validate_agent_spec()"
          - "validate_workflow_spec()"
          - "validate_tool_spec()"
      - path: "services/agent-engine/specs/agents/examples/analyzer.yaml"
        purpose: "Example agent specification"
      - path: "services/agent-engine/specs/workflows/examples/sequential-process.yaml"
        purpose: "Example workflow specification"
      - path: "services/agent-engine/specs/tools/examples/text-analyzer.yaml"
        purpose: "Example tool specification"
      - path: "services/agent-engine/specs/schemas/agent-spec.json"
        purpose: "JSON Schema for agent specifications"
      - path: "services/agent-engine/tests/test_specifications.py"
        purpose: "Specification system tests"
        
    modifies:
      - path: "services/agent-engine/src/main.py"
        changes: ["Add specification validation endpoint"]
        
    uses_from_previous:
      - component: "Project structure"
        from_task: "r1-t01"
        usage: "Add specification directories"
      - component: "ADK imports"
        from_task: "r1-t02"
        usage: "Validate against ADK requirements"
    
  implementation_steps:
    - step: "Create specification models"
      focus:
        - "Define Pydantic models for all spec types"
        - "Add validation rules"
        - "Support all ADK agent parameters"
        - "Enable extensibility"
      code_template: |
        from pydantic import BaseModel, Field, validator
        from typing import Dict, Any, List, Optional, Union
        from enum import Enum
        
        class AgentType(str, Enum):
            LLM = "llm"
            SEQUENTIAL = "sequential"
            PARALLEL = "parallel"
            LOOP = "loop"
            CUSTOM = "custom"
        
        class ModelConfig(BaseModel):
            primary: str
            fallbacks: List[str] = []
            parameters: Dict[str, Any] = {}
        
        class AgentConfig(BaseModel):
            type: AgentType
            model: Optional[ModelConfig] = None
            instruction_template: Optional[str] = None
            parameters: Dict[str, Any] = {}
        
        class ToolReference(BaseModel):
            name: str
            source: str = "registry"  # registry, inline, import
            definition: Optional[str] = None
            module: Optional[str] = None
        
        class SubAgentReference(BaseModel):
            spec_ref: str
            condition: Optional[str] = None
        
        class AgentSpecification(BaseModel):
            apiVersion: str = "agent-engine/v1"
            kind: str = "AgentSpec"
            metadata: Dict[str, Any]
            spec: Dict[str, Any]
            
            @validator("apiVersion")
            def validate_version(cls, v):
                if not v.startswith("agent-engine/"):
                    raise ValueError("Invalid API version")
                return v
            
            @validator("kind")
            def validate_kind(cls, v):
                valid_kinds = ["AgentSpec", "WorkflowTemplate", "ToolSpec", "ModelConfig"]
                if v not in valid_kinds:
                    raise ValueError(f"Invalid kind: {v}")
                return v
    
    - step: "Create specification parser"
      focus:
        - "Parse YAML and JSON files"
        - "Handle template variables"
        - "Support includes and references"
        - "Error handling and reporting"
      code_template: |
        import yaml
        import json
        from pathlib import Path
        from typing import Dict, Any
        
        class SpecificationParser:
            def __init__(self, base_path: str = "specs"):
                self.base_path = Path(base_path)
            
            def load_spec(self, spec_path: str) -> Dict[str, Any]:
                """Load specification from file."""
                full_path = self.base_path / spec_path
                
                if full_path.suffix == ".yaml" or full_path.suffix == ".yml":
                    return self._load_yaml(full_path)
                elif full_path.suffix == ".json":
                    return self._load_json(full_path)
                else:
                    raise ValueError(f"Unsupported file format: {full_path.suffix}")
            
            def _load_yaml(self, path: Path) -> Dict[str, Any]:
                """Load YAML specification."""
                with open(path, 'r') as f:
                    return yaml.safe_load(f)
            
            def _load_json(self, path: Path) -> Dict[str, Any]:
                """Load JSON specification."""
                with open(path, 'r') as f:
                    return json.load(f)
            
            def resolve_references(self, spec: Dict[str, Any]) -> Dict[str, Any]:
                """Resolve references in specification."""
                # Handle $ref references
                if "$ref" in spec:
                    ref_path = spec["$ref"]
                    referenced = self.load_spec(ref_path)
                    spec.update(referenced)
                    del spec["$ref"]
                
                # Recursively resolve nested references
                for key, value in spec.items():
                    if isinstance(value, dict):
                        spec[key] = self.resolve_references(value)
                    elif isinstance(value, list):
                        spec[key] = [
                            self.resolve_references(item) if isinstance(item, dict) else item
                            for item in value
                        ]
                
                return spec
      
    - step: "Create specification validator"
      focus:
        - "Validate against JSON schemas"
        - "Check ADK compatibility"
        - "Verify references exist"
        - "Validate template variables"
      code_template: |
        from jsonschema import validate, ValidationError
        
        class SpecificationValidator:
            def __init__(self):
                self.schemas = self._load_schemas()
            
            def validate_spec(self, spec: Dict[str, Any]) -> bool:
                """Validate specification against schema."""
                kind = spec.get("kind")
                if not kind:
                    raise ValueError("Missing 'kind' field in specification")
                
                schema = self.schemas.get(kind)
                if not schema:
                    raise ValueError(f"No schema found for kind: {kind}")
                
                try:
                    validate(instance=spec, schema=schema)
                    return True
                except ValidationError as e:
                    raise ValueError(f"Specification validation failed: {e.message}")
            
            def validate_agent_spec(self, spec: Dict[str, Any]) -> bool:
                """Validate agent specification."""
                # Validate general structure
                self.validate_spec(spec)
                
                # Validate ADK compatibility
                agent_type = spec["spec"]["agent"]["type"]
                if agent_type == "llm":
                    self._validate_llm_agent(spec["spec"]["agent"])
                elif agent_type in ["sequential", "parallel"]:
                    self._validate_workflow_agent(spec["spec"]["agent"])
                
                return True
            
            def _validate_llm_agent(self, agent_config: Dict[str, Any]):
                """Validate LLM agent configuration."""
                required = ["model", "instruction_template"]
                for field in required:
                    if field not in agent_config:
                        raise ValueError(f"Missing required field for LLM agent: {field}")
    
    - step: "Create example specifications"
      focus:
        - "Create agent specification examples"
        - "Create workflow template examples"
        - "Create tool specification examples"
        - "Include all supported patterns"
      yaml_template: |
        # Agent Specification Example
        apiVersion: agent-engine/v1
        kind: AgentSpec
        metadata:
          name: content-analyzer
          version: 1.0.0
          description: Analyzes content using configurable strategies
          tags: [analysis, configurable]
          author: agent-engine-team
        
        spec:
          agent:
            type: llm
            model:
              primary: gemini-2.0-flash
              fallbacks: [gemini-2.5-pro]
              parameters:
                temperature: 0.2
                max_tokens: 8192
            instruction_template: |
              You are a {role} specializing in {domain}.
              Your task is to analyze the provided content and {objective}.
              
              Guidelines:
              - Be thorough and systematic
              - Provide structured output
              - Include confidence scores
            
          tools:
            - name: extract_entities
              source: registry
            - name: calculate_score
              source: inline
              definition: |
                def calculate_score(data: dict) -> float:
                    # Score calculation logic
                    return 0.85
          
          sub_agents:
            - spec_ref: detail-extractor
              condition: input.get('detailed', False)
          
          validation:
            input_schema:
              type: object
              properties:
                content:
                  type: string
                options:
                  type: object
              required: [content]
    
    - step: "Create JSON schemas"
      focus:
        - "Define JSON Schema for each specification type"
        - "Include all required fields"
        - "Add validation rules"
        - "Document schema properties"
    
    - step: "Add validation endpoint"
      focus:
        - "Add /specs/validate endpoint"
        - "Accept specification upload"
        - "Return validation results"
        - "Provide helpful error messages"
    
    - step: "Create comprehensive tests"
      focus:
        - "Test parsing various formats"
        - "Test validation rules"
        - "Test reference resolution"
        - "Test error handling"
    
  validation:
    commands:
      - desc: "Test specification parser"
        run: "python -c 'from core.specifications import SpecificationParser; parser = SpecificationParser(); spec = parser.load_spec(\"agents/examples/analyzer.yaml\"); print(\"Parser OK\")'"
        expects: "Parser OK"
        
      - desc: "Test specification validator"
        run: "python -c 'from core.specifications import SpecificationValidator; validator = SpecificationValidator(); print(\"Validator OK\")'"
        expects: "Validator OK"
        
      - desc: "Run specification tests"
        run: "pytest services/agent-engine/tests/test_specifications.py -v"
        expects: "All tests pass"
        
      - desc: "Validate example specifications"
        run: "python scripts/validate_specs.py specs/"
        expects: "All specifications valid"
        
      - desc: "Test validation endpoint"
        run: "curl -X POST localhost:8001/specs/validate -d @specs/agents/examples/analyzer.yaml"
        expects: '{"valid": true}'
        
    endpoints:
      - method: "POST"
        path: "/specs/validate"
        body: "@specs/agents/examples/analyzer.yaml"
        expects: '{"valid": true, "kind": "AgentSpec"}'
        
    integration:
      - desc: "Complete specification system test"
        steps:
          - "Parse YAML specification"
          - "Validate against schema"
          - "Resolve references"
          - "Check ADK compatibility"
    
  success_criteria:
    - "Specification parser handles YAML and JSON"
    - "Validator checks against schemas"
    - "Reference resolution works"
    - "Template variables supported"
    - "Example specifications validate"
    - "Tests achieve 85% coverage"
    - "Validation endpoint functional"
    - "Error messages are helpful"
    
  session_notes:
    decisions_made:
      - "Use YAML as primary format with JSON support"
      - "Pydantic for model validation"
      - "JSON Schema for specification validation"
      - "Support template variables for reusability"
    patterns_established:
      - "Specification structure (apiVersion, kind, metadata, spec)"
      - "Reference resolution pattern"
      - "Validation pipeline"
      - "Error reporting format"
    context_for_next:
      - "Specification system ready for use"
      - "Validation pipeline established"
      - "Example specifications available"
      - "Ready for database setup"