task:
  id: "r5-t01-session-orchestration"
  name: "Implement Session Orchestration System"
  description: "Create comprehensive session management system with multiple persistence backends, lifecycle management, and enterprise features"
  complexity: "medium"
  estimated_hours: 6  # CORRECTED: Increased from 4 to account for additional requirements
  
  context:
    why: "Sessions provide stateful interactions, conversation history, and context persistence across agent executions"
    architectural_role: "Central session management layer for all agent interactions"
    depends_on_tasks: ["r1-t01", "r2-t05"]
    enables_tasks: ["r5-t02", "r5-t03", "r5-t04"]
    references:
      masterplan: "@MASTERPLAN.md#session-management"
      adk_patterns: "@tasks/adk-patterns.md#session-services"
      architecture: "@memory-bank/architecture.md#session-management"
    
  adk_components:
    primary:
      - component: "InMemorySessionService"
        usage: "Default session backend for development and testing"  # VERIFIED: ADK docs confirm this usage
      - component: "VertexAiSessionService"  # ADDED: From masterplan enterprise requirements
        usage: "Enterprise session backend for production with persistent storage"
      - component: "Session"
        usage: "Session state management and conversation history"  # VERIFIED: ADK docs confirm session properties
      - component: "InMemoryRunner"
        usage: "Session-aware execution with automatic session_service property"  # VERIFIED: ADK docs confirm session_service property pattern
    patterns:
      - "Multi-backend session support (Memory, Redis, VertexAI)"  # CORRECTED: Added VertexAI from masterplan
      - "Session forking and merging for conversation branching"
      - "State persistence across executions"
      - "Session-scoped agent instances"  # ADDED: From masterplan requirements
      - "Database integration for audit trails"  # ADDED: From masterplan database entities
      - "Session lifecycle hooks and event system"  # ADDED: From masterplan session orchestration
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/session.py"
        purpose: "Core session orchestration system"
        exports:
          - "SessionOrchestrator: Main session coordinator with multi-backend support"
          - "SessionBackend: Abstract backend interface for all persistence types"
          - "MemoryBackend: In-memory session backend using ADK InMemorySessionService"  # VERIFIED: ADK pattern
          - "RedisBackend: Redis session backend for distributed systems"
          - "VertexBackend: VertexAI session backend for enterprise features"  # ADDED: From masterplan enterprise requirements
          - "SessionLifecycle: Session lifecycle management with hooks"
          - "SessionContext: Session execution context for agent instances"
          - "SessionSynchronizer: Session state synchronization between backends"  # ADDED: From masterplan requirements
          - "SessionAnalytics: Session metrics and analytics collection"  # ADDED: From masterplan monitoring requirements
        content_structure: |
          from typing import Dict, Any, List, Optional, Protocol, AsyncIterator, Callable  # ADDED: Callable for lifecycle hooks
          from datetime import datetime, timedelta
          from pydantic import BaseModel, Field
          import logging
          import json
          import asyncio
          from abc import ABC, abstractmethod
          from uuid import uuid4
          
          from google.adk.sessions import InMemorySessionService, VertexAiSessionService, Session  # VERIFIED: ADK docs confirm VertexAiSessionService
          from google.adk.runners import InMemoryRunner
          import redis.asyncio as redis
          from ..services.database import DatabaseService  # ADDED: Database integration from masterplan
          from ..models.database import SessionEntity, ExecutionEntity  # ADDED: Database entities from masterplan
          
          logger = logging.getLogger(__name__)
          
          class SessionMetadata(BaseModel):
              """Session metadata and configuration"""
              session_id: str
              user_id: str
              app_name: str
              created_at: datetime = Field(default_factory=datetime.now)
              updated_at: datetime = Field(default_factory=datetime.now)
              tags: List[str] = Field(default_factory=list)
              config: Dict[str, Any] = Field(default_factory=dict)
              parent_session_id: Optional[str] = None  # For forked sessions
              is_active: bool = True
              ttl_seconds: Optional[int] = None
          
          class SessionState(BaseModel):
              """Session state container"""
              conversation_history: List[Dict[str, Any]] = Field(default_factory=list)
              context: Dict[str, Any] = Field(default_factory=dict)
              variables: Dict[str, Any] = Field(default_factory=dict)
              checkpoints: List[Dict[str, Any]] = Field(default_factory=list)
              metrics: Dict[str, Any] = Field(default_factory=dict)
          
          class SessionBackend(ABC):
              """Abstract interface for session persistence backends"""
              
              @abstractmethod
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create new session"""
                  pass
              
              @abstractmethod
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[tuple[SessionMetadata, SessionState]]:
                  """Retrieve session"""
                  pass
              
              @abstractmethod
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session state"""
                  pass
              
              @abstractmethod
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session"""
                  pass
              
              @abstractmethod
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions with filters"""
                  pass
              
              @abstractmethod
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session creating a copy"""
                  pass
          
          class MemoryBackend(SessionBackend):
              """In-memory session backend using ADK's InMemorySessionService"""
              
              def __init__(self):
                  self.adk_service = InMemorySessionService()
                  self.metadata_store: Dict[str, SessionMetadata] = {}
                  self.state_store: Dict[str, SessionState] = {}
                  self._lock = asyncio.Lock()
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in memory"""
                  async with self._lock:
                      # Create ADK session
                      adk_session = self.adk_service.create_session(
                          app_name=metadata.app_name,
                          user_id=metadata.user_id,
                          session_id=metadata.session_id
                      )
                      
                      # Store metadata and state
                      self.metadata_store[metadata.session_id] = metadata
                      self.state_store[metadata.session_id] = initial_state or SessionState()
                      
                      logger.info(f"Created memory session: {metadata.session_id}")
                      return metadata.session_id
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[tuple[SessionMetadata, SessionState]]:
                  """Get session from memory"""
                  async with self._lock:
                      if session_id in self.metadata_store:
                          return (
                              self.metadata_store[session_id],
                              self.state_store[session_id]
                          )
                      return None
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in memory"""
                  async with self._lock:
                      if session_id not in self.metadata_store:
                          return False
                      
                      self.state_store[session_id] = state
                      
                      if metadata_update:
                          metadata = self.metadata_store[session_id]
                          for key, value in metadata_update.items():
                              setattr(metadata, key, value)
                          metadata.updated_at = datetime.now()
                      
                      return True
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from memory"""
                  async with self._lock:
                      if session_id in self.metadata_store:
                          del self.metadata_store[session_id]
                          del self.state_store[session_id]
                          
                          # Delete from ADK service
                          self.adk_service.delete_session(session_id)
                          return True
                      return False
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from memory"""
                  async with self._lock:
                      sessions = list(self.metadata_store.values())
                      
                      # Apply filters
                      if user_id:
                          sessions = [s for s in sessions if s.user_id == user_id]
                      if app_name:
                          sessions = [s for s in sessions if s.app_name == app_name]
                      if active_only:
                          sessions = [s for s in sessions if s.is_active]
                      
                      return sessions
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in memory"""
                  async with self._lock:
                      if source_session_id not in self.metadata_store:
                          return None
                      
                      # Copy metadata
                      source_metadata = self.metadata_store[source_session_id]
                      new_metadata = SessionMetadata(
                          session_id=new_session_id,
                          user_id=source_metadata.user_id,
                          app_name=source_metadata.app_name,
                          parent_session_id=source_session_id,
                          tags=source_metadata.tags.copy(),
                          config=source_metadata.config.copy()
                      )
                      
                      # Copy state
                      source_state = self.state_store[source_session_id]
                      new_state = SessionState(
                          conversation_history=source_state.conversation_history.copy(),
                          context=source_state.context.copy(),
                          variables=source_state.variables.copy()
                      )
                      
                      # Create forked session
                      await self.create_session(new_metadata, new_state)
                      return new_session_id
          
          class RedisBackend(SessionBackend):
              """Redis-backed session storage for distributed systems"""
              
              def __init__(
                  self,
                  redis_client: redis.Redis,
                  prefix: str = "session:",
                  default_ttl: int = 86400  # 24 hours
              ):
                  self.redis = redis_client
                  self.prefix = prefix
                  self.default_ttl = default_ttl
              
              def _get_metadata_key(self, session_id: str) -> str:
                  return f"{self.prefix}metadata:{session_id}"
              
              def _get_state_key(self, session_id: str) -> str:
                  return f"{self.prefix}state:{session_id}"
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in Redis"""
                  try:
                      metadata_key = self._get_metadata_key(metadata.session_id)
                      state_key = self._get_state_key(metadata.session_id)
                      
                      ttl = metadata.ttl_seconds or self.default_ttl
                      
                      # Store metadata
                      await self.redis.setex(
                          metadata_key,
                          ttl,
                          json.dumps(metadata.model_dump(mode='json'), default=str)
                      )
                      
                      # Store state
                      state = initial_state or SessionState()
                      await self.redis.setex(
                          state_key,
                          ttl,
                          json.dumps(state.model_dump(mode='json'), default=str)
                      )
                      
                      logger.info(f"Created Redis session: {metadata.session_id}")
                      return metadata.session_id
                      
                  except Exception as e:
                      logger.error(f"Failed to create Redis session: {e}")
                      raise
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[tuple[SessionMetadata, SessionState]]:
                  """Get session from Redis"""
                  try:
                      metadata_key = self._get_metadata_key(session_id)
                      state_key = self._get_state_key(session_id)
                      
                      # Get metadata and state
                      metadata_json = await self.redis.get(metadata_key)
                      state_json = await self.redis.get(state_key)
                      
                      if metadata_json and state_json:
                          metadata = SessionMetadata(**json.loads(metadata_json))
                          state = SessionState(**json.loads(state_json))
                          return (metadata, state)
                      
                      return None
                      
                  except Exception as e:
                      logger.error(f"Failed to get Redis session: {e}")
                      return None
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in Redis"""
                  try:
                      # Get current session
                      session_data = await self.get_session(session_id)
                      if not session_data:
                          return False
                      
                      metadata, _ = session_data
                      
                      # Update metadata if provided
                      if metadata_update:
                          for key, value in metadata_update.items():
                              setattr(metadata, key, value)
                          metadata.updated_at = datetime.now()
                      
                      # Calculate TTL
                      ttl = metadata.ttl_seconds or self.default_ttl
                      
                      # Store updated data
                      metadata_key = self._get_metadata_key(session_id)
                      state_key = self._get_state_key(session_id)
                      
                      await self.redis.setex(
                          metadata_key,
                          ttl,
                          json.dumps(metadata.model_dump(mode='json'), default=str)
                      )
                      
                      await self.redis.setex(
                          state_key,
                          ttl,
                          json.dumps(state.model_dump(mode='json'), default=str)
                      )
                      
                      return True
                      
                  except Exception as e:
                      logger.error(f"Failed to update Redis session: {e}")
                      return False
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from Redis"""
                  try:
                      metadata_key = self._get_metadata_key(session_id)
                      state_key = self._get_state_key(session_id)
                      
                      result = await self.redis.delete(metadata_key, state_key)
                      return result > 0
                      
                  except Exception as e:
                      logger.error(f"Failed to delete Redis session: {e}")
                      return False
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from Redis"""
                  try:
                      sessions = []
                      pattern = f"{self.prefix}metadata:*"
                      
                      async for key in self.redis.scan_iter(match=pattern):
                          metadata_json = await self.redis.get(key)
                          if metadata_json:
                              metadata = SessionMetadata(**json.loads(metadata_json))
                              
                              # Apply filters
                              if user_id and metadata.user_id != user_id:
                                  continue
                              if app_name and metadata.app_name != app_name:
                                  continue
                              if active_only and not metadata.is_active:
                                  continue
                              
                              sessions.append(metadata)
                      
                      return sessions
                      
                  except Exception as e:
                      logger.error(f"Failed to list Redis sessions: {e}")
                      return []
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in Redis"""
                  session_data = await self.get_session(source_session_id)
                  if not session_data:
                      return None
                  
                  source_metadata, source_state = session_data
                  
                  # Create forked metadata
                  new_metadata = SessionMetadata(
                      session_id=new_session_id,
                      user_id=source_metadata.user_id,
                      app_name=source_metadata.app_name,
                      parent_session_id=source_session_id,
                      tags=source_metadata.tags.copy(),
                      config=source_metadata.config.copy()
                  )
                  
                  # Create forked state
                  new_state = SessionState(
                      conversation_history=source_state.conversation_history.copy(),
                      context=source_state.context.copy(),
                      variables=source_state.variables.copy()
                  )
                  
                  # Create forked session
                  await self.create_session(new_metadata, new_state)
                  return new_session_id
          
          class VertexBackend(SessionBackend):
              """VertexAI session backend for enterprise features"""  # ADDED: From masterplan enterprise requirements
              
              def __init__(
                  self,
                  project_id: str,
                  location: str = "us-central1",
                  reasoning_engine_id: Optional[str] = None
              ):
                  # VERIFIED: ADK docs confirm VertexAiSessionService parameters
                  self.vertex_service = VertexAiSessionService(
                      project=project_id,
                      location=location
                  )
                  self.project_id = project_id
                  self.location = location
                  self.reasoning_engine_id = reasoning_engine_id
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in VertexAI"""
                  try:
                      # VERIFIED: ADK docs confirm session creation pattern
                      app_name = self.reasoning_engine_id or f"projects/{self.project_id}/locations/{self.location}/reasoningEngines/default"
                      
                      session = await self.vertex_service.create_session(
                          app_name=app_name,
                          user_id=metadata.user_id,
                          session_id=metadata.session_id,
                          state=initial_state.model_dump() if initial_state else {}
                      )
                      
                      logger.info(f"Created VertexAI session: {metadata.session_id}")
                      return session.id
                      
                  except Exception as e:
                      logger.error(f"Failed to create VertexAI session: {e}")
                      raise
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[tuple[SessionMetadata, SessionState]]:
                  """Get session from VertexAI"""
                  try:
                      session = await self.vertex_service.get_session(session_id)
                      if session:
                          # Convert VertexAI session back to our format
                          metadata = SessionMetadata(
                              session_id=session.id,
                              user_id=session.user_id,
                              app_name=session.app_name,
                              created_at=session.created_time or datetime.now(),
                              updated_at=session.last_update_time or datetime.now()
                          )
                          state = SessionState(**session.state)
                          return (metadata, state)
                      
                      return None
                      
                  except Exception as e:
                      logger.error(f"Failed to get VertexAI session: {e}")
                      return None
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in VertexAI"""
                  try:
                      # VertexAI sessions are updated via append_event mechanism
                      session = await self.vertex_service.get_session(session_id)
                      if session:
                          session.state = state.model_dump()
                          return True
                      return False
                      
                  except Exception as e:
                      logger.error(f"Failed to update VertexAI session: {e}")
                      return False
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from VertexAI"""
                  try:
                      await self.vertex_service.delete_session(session_id)
                      return True
                  except Exception as e:
                      logger.error(f"Failed to delete VertexAI session: {e}")
                      return False
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from VertexAI"""
                  try:
                      sessions = await self.vertex_service.list_sessions(
                          app_name=app_name,
                          user_id=user_id
                      )
                      
                      result = []
                      for session in sessions:
                          metadata = SessionMetadata(
                              session_id=session.id,
                              user_id=session.user_id,
                              app_name=session.app_name,
                              created_at=session.created_time or datetime.now(),
                              updated_at=session.last_update_time or datetime.now(),
                              is_active=True  # VertexAI manages active state
                          )
                          result.append(metadata)
                      
                      return result
                      
                  except Exception as e:
                      logger.error(f"Failed to list VertexAI sessions: {e}")
                      return []
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in VertexAI"""
                  session_data = await self.get_session(source_session_id)
                  if not session_data:
                      return None
                  
                  source_metadata, source_state = session_data
                  
                  # Create forked metadata
                  new_metadata = SessionMetadata(
                      session_id=new_session_id,
                      user_id=source_metadata.user_id,
                      app_name=source_metadata.app_name,
                      parent_session_id=source_session_id,
                      tags=source_metadata.tags.copy(),
                      config=source_metadata.config.copy()
                  )
                  
                  # Create forked state
                  new_state = SessionState(
                      conversation_history=source_state.conversation_history.copy(),
                      context=source_state.context.copy(),
                      variables=source_state.variables.copy()
                  )
                  
                  # Create forked session
                  await self.create_session(new_metadata, new_state)
                  return new_session_id
          
          class SessionContext:
              """Session execution context for agents"""
              
              def __init__(
                  self,
                  session_id: str,
                  metadata: SessionMetadata,
                  state: SessionState
              ):
                  self.session_id = session_id
                  self.metadata = metadata
                  self.state = state
                  self.start_time = datetime.now()
                  self.events: List[Dict] = []
              
              def add_message(self, role: str, content: str):
                  """Add message to conversation history"""
                  message = {
                      "role": role,
                      "content": content,
                      "timestamp": datetime.now().isoformat()
                  }
                  self.state.conversation_history.append(message)
              
              def set_variable(self, key: str, value: Any):
                  """Set session variable"""
                  self.state.variables[key] = value
              
              def get_variable(self, key: str, default: Any = None) -> Any:
                  """Get session variable"""
                  return self.state.variables.get(key, default)
              
              def checkpoint(self) -> Dict:
                  """Create session checkpoint"""
                  checkpoint = {
                      "timestamp": datetime.now().isoformat(),
                      "conversation_length": len(self.state.conversation_history),
                      "variables": self.state.variables.copy(),
                      "context": self.state.context.copy()
                  }
                  self.state.checkpoints.append(checkpoint)
                  return checkpoint
              
              def get_metrics(self) -> Dict:
                  """Get session metrics"""
                  return {
                      "duration_seconds": (datetime.now() - self.start_time).total_seconds(),
                      "message_count": len(self.state.conversation_history),
                      "variable_count": len(self.state.variables),
                      "checkpoint_count": len(self.state.checkpoints),
                      "event_count": len(self.events)
                  }
          
          class SessionLifecycle:
              """Manages session lifecycle events and hooks"""
              
              def __init__(self):
                  self.hooks = {
                      "on_create": [],
                      "on_update": [],
                      "on_delete": [],
                      "on_fork": [],
                      "on_expire": []
                  }
              
              def register_hook(
                  self,
                  event: str,
                  callback: Callable
              ):
                  """Register lifecycle hook"""
                  if event in self.hooks:
                      self.hooks[event].append(callback)
              
              async def trigger_hook(
                  self,
                  event: str,
                  session_id: str,
                  **kwargs
              ):
                  """Trigger lifecycle hooks"""
                  if event in self.hooks:
                      for callback in self.hooks[event]:
                          try:
                              if asyncio.iscoroutinefunction(callback):
                                  await callback(session_id, **kwargs)
                              else:
                                  callback(session_id, **kwargs)
                          except Exception as e:
                              logger.error(f"Hook error for {event}: {e}")
          
          class SessionOrchestrator:
              """Main session orchestration coordinator"""
              
              def __init__(
                  self,
                  backend: Optional[SessionBackend] = None,
                  enable_lifecycle: bool = True
              ):
                  self.backend = backend or MemoryBackend()
                  self.lifecycle = SessionLifecycle() if enable_lifecycle else None
                  self.active_contexts: Dict[str, SessionContext] = {}
                  self.session_metrics: Dict[str, Dict] = {}
              
              async def create_session(
                  self,
                  user_id: str,
                  app_name: str,
                  session_id: Optional[str] = None,
                  config: Optional[Dict] = None,
                  initial_state: Optional[Dict] = None
              ) -> SessionContext:
                  """Create new session with context"""
                  session_id = session_id or f"session_{uuid4().hex[:12]}"
                  
                  # Create metadata
                  metadata = SessionMetadata(
                      session_id=session_id,
                      user_id=user_id,
                      app_name=app_name,
                      config=config or {}
                  )
                  
                  # Create initial state
                  state = SessionState()
                  if initial_state:
                      state.context = initial_state
                  
                  # Create in backend
                  await self.backend.create_session(metadata, state)
                  
                  # Create context
                  context = SessionContext(session_id, metadata, state)
                  self.active_contexts[session_id] = context
                  
                  # Trigger lifecycle hook
                  if self.lifecycle:
                      await self.lifecycle.trigger_hook(
                          "on_create",
                          session_id,
                          metadata=metadata
                      )
                  
                  logger.info(f"Created session {session_id} for user {user_id}")
                  return context
              
              async def get_session(
                  self,
                  session_id: str,
                  activate: bool = True
              ) -> Optional[SessionContext]:
                  """Get session context"""
                  # Check active contexts
                  if session_id in self.active_contexts:
                      return self.active_contexts[session_id]
                  
                  # Load from backend
                  session_data = await self.backend.get_session(session_id)
                  if session_data:
                      metadata, state = session_data
                      context = SessionContext(session_id, metadata, state)
                      
                      if activate:
                          self.active_contexts[session_id] = context
                      
                      return context
                  
                  return None
              
              async def update_session(
                  self,
                  session_id: str,
                  context: Optional[SessionContext] = None
              ) -> bool:
                  """Update session state"""
                  if not context:
                      context = self.active_contexts.get(session_id)
                  
                  if not context:
                      return False
                  
                  # Update backend
                  success = await self.backend.update_session(
                      session_id,
                      context.state,
                      {"updated_at": datetime.now()}
                  )
                  
                  # Trigger lifecycle hook
                  if success and self.lifecycle:
                      await self.lifecycle.trigger_hook(
                          "on_update",
                          session_id,
                          state=context.state
                      )
                  
                  return success
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session"""
                  # Remove from active contexts
                  if session_id in self.active_contexts:
                      del self.active_contexts[session_id]
                  
                  # Delete from backend
                  success = await self.backend.delete_session(session_id)
                  
                  # Trigger lifecycle hook
                  if success and self.lifecycle:
                      await self.lifecycle.trigger_hook(
                          "on_delete",
                          session_id
                      )
                  
                  return success
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: Optional[str] = None
              ) -> Optional[SessionContext]:
                  """Fork session creating a branch"""
                  new_session_id = new_session_id or f"session_{uuid4().hex[:12]}"
                  
                  # Fork in backend
                  result = await self.backend.fork_session(
                      source_session_id,
                      new_session_id
                  )
                  
                  if result:
                      # Get forked session
                      context = await self.get_session(new_session_id)
                      
                      # Trigger lifecycle hook
                      if context and self.lifecycle:
                          await self.lifecycle.trigger_hook(
                              "on_fork",
                              new_session_id,
                              parent_id=source_session_id
                          )
                      
                      return context
                  
                  return None
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions with filters"""
                  return await self.backend.list_sessions(
                      user_id,
                      app_name,
                      active_only
                  )
              
              def get_metrics(self) -> Dict:
                  """Get orchestrator metrics"""
                  return {
                      "active_sessions": len(self.active_contexts),
                      "backend_type": type(self.backend).__name__,
                      "lifecycle_enabled": self.lifecycle is not None
                  }
              
              async def create_scoped_agent(
                  self,
                  session_id: str,
                  agent_config: Dict
              ) -> Any:
                  """Create session-scoped agent instance"""  # ADDED: From masterplan requirements
                  context = await self.get_session(session_id)
                  if not context:
                      raise ValueError(f"Session {session_id} not found")
                  
                  # Agent will be bound to this session context
                  return self._create_agent_with_context(agent_config, context)
              
              def _create_agent_with_context(self, agent_config: Dict, context: SessionContext) -> Any:
                  """Helper to create agent with session context"""
                  # Implementation will integrate with agent composition service
                  pass
          
          class SessionSynchronizer:
              """Session state synchronization between backends"""  # ADDED: From masterplan requirements
              
              def __init__(self, primary_backend: SessionBackend, secondary_backend: SessionBackend):
                  self.primary = primary_backend
                  self.secondary = secondary_backend
                  self.sync_interval = 30  # seconds
                  self.sync_enabled = True
              
              async def start_sync(self):
                  """Start continuous synchronization"""
                  while self.sync_enabled:
                      try:
                          await self._sync_sessions()
                          await asyncio.sleep(self.sync_interval)
                      except Exception as e:
                          logger.error(f"Sync error: {e}")
                          await asyncio.sleep(self.sync_interval)
              
              async def _sync_sessions(self):
                  """Synchronize sessions between backends"""
                  primary_sessions = await self.primary.list_sessions()
                  
                  for session_metadata in primary_sessions:
                      try:
                          session_data = await self.primary.get_session(session_metadata.session_id)
                          if session_data:
                              metadata, state = session_data
                              # Ensure secondary has latest state
                              await self.secondary.update_session(
                                  session_metadata.session_id,
                                  state,
                                  {"synced_at": datetime.now()}
                              )
                      except Exception as e:
                          logger.error(f"Failed to sync session {session_metadata.session_id}: {e}")
              
              async def stop_sync(self):
                  """Stop synchronization"""
                  self.sync_enabled = False
          
          class SessionAnalytics:
              """Session metrics and analytics collection"""  # ADDED: From masterplan monitoring requirements
              
              def __init__(self, database_service: Optional[DatabaseService] = None):
                  self.database = database_service
                  self.metrics_cache: Dict[str, Dict] = {}
                  self.analytics_enabled = True
              
              async def track_session_event(
                  self,
                  session_id: str,
                  event_type: str,
                  event_data: Dict[str, Any]
              ):
                  """Track session event for analytics"""
                  if not self.analytics_enabled:
                      return
                  
                  event = {
                      "session_id": session_id,
                      "event_type": event_type,
                      "event_data": event_data,
                      "timestamp": datetime.now().isoformat()
                  }
                  
                  # Cache locally
                  if session_id not in self.metrics_cache:
                      self.metrics_cache[session_id] = {"events": []}
                  self.metrics_cache[session_id]["events"].append(event)
                  
                  # Persist to database if available
                  if self.database:
                      await self._persist_event(event)
              
              async def _persist_event(self, event: Dict):
                  """Persist event to database"""
                  try:
                      # Integration with database service for audit trail
                      await self.database.create_audit_log(
                          session_id=event["session_id"],
                          event_type=event["event_type"],
                          event_data=event["event_data"],
                          timestamp=event["timestamp"]
                      )
                  except Exception as e:
                      logger.error(f"Failed to persist analytics event: {e}")
              
              def get_session_analytics(self, session_id: str) -> Dict:
                  """Get analytics for specific session"""
                  return self.metrics_cache.get(session_id, {})
              
              def get_global_analytics(self) -> Dict:
                  """Get global session analytics"""
                  total_sessions = len(self.metrics_cache)
                  total_events = sum(len(session.get("events", [])) for session in self.metrics_cache.values())
                  
                  return {
                      "total_sessions": total_sessions,
                      "total_events": total_events,
                      "average_events_per_session": total_events / total_sessions if total_sessions > 0 else 0,
                      "cache_size": len(self.metrics_cache)
                  }
              
              async def cleanup_old_metrics(self, days_old: int = 7):
                  """Clean up old metrics data"""
                  cutoff_date = datetime.now() - timedelta(days=days_old)
                  
                  # Remove old cached data
                  sessions_to_remove = []
                  for session_id, session_data in self.metrics_cache.items():
                      events = session_data.get("events", [])
                      if events:
                          latest_event = max(events, key=lambda e: e["timestamp"])
                          event_date = datetime.fromisoformat(latest_event["timestamp"])
                          if event_date < cutoff_date:
                              sessions_to_remove.append(session_id)
                  
                  for session_id in sessions_to_remove:
                      del self.metrics_cache[session_id]
                  
                  logger.info(f"Cleaned up {len(sessions_to_remove)} old session metrics")
      
      - path: "services/agent-engine/tests/test_session_orchestration.py"
        purpose: "Tests for session orchestration"
        test_categories:
          - "Session creation and lifecycle with all backends"  # CORRECTED: Include all three backends
          - "Backend operations (Memory, Redis, VertexAI)"  # CORRECTED: Specify all backends
          - "Session forking and merging"
          - "Context management and scoped agents"  # CORRECTED: Include scoped agents
          - "Metrics collection and analytics"  # CORRECTED: Include analytics
          - "Session synchronization between backends"  # ADDED: From masterplan requirements
          - "Database integration and audit trails"  # ADDED: From masterplan database entities
          - "Enterprise features (VertexAI backend)"  # ADDED: Enterprise testing
    
    uses_from_previous:
      - source: "r1-t01"
        component: "Project setup"
        usage: "Base infrastructure"
      - source: "r2-t05"
        component: "Runner integration"
        usage: "Session-aware execution"
    
  implementation_steps:
    - step: "Create session models and interfaces"
      implementation_notes: |
        - SessionMetadata structure with enterprise fields
        - SessionState container with analytics support
        - SessionBackend abstract interface
        - SessionContext wrapper with agent binding
        
    - step: "Implement all session backends"  # CORRECTED: Include all three backends
      implementation_notes: |
        - MemoryBackend with ADK InMemorySessionService
        - RedisBackend for distributed systems
        - VertexBackend with ADK VertexAiSessionService  # ADDED: Enterprise backend
        - Backend configuration and selection logic
        
    - step: "Build session orchestrator"
      implementation_notes: |
        - Multi-backend session management
        - Session-scoped agent instance creation  # ADDED: From masterplan
        - Context handling and state management
        - Lifecycle hooks and event system
        
    - step: "Add enterprise features"  # ADDED: New step for enterprise requirements
      implementation_notes: |
        - Session synchronization between backends
        - Database integration for audit trails
        - Analytics and metrics collection
        - Session cleanup and TTL management
        
    - step: "Implement session forking and merging"
      implementation_notes: |
        - Fork operation across all backends
        - Parent tracking and relationship mapping
        - State copying and isolation
        - Merge strategies for conversation branches
        
    - step: "Write comprehensive tests"
      implementation_notes: |
        - Test all three backends (Memory, Redis, VertexAI)
        - Lifecycle and hook testing
        - Fork and merge scenarios
        - Synchronization testing between backends  # ADDED
        - Database integration testing  # ADDED
        - Enterprise feature validation  # ADDED
        
  validation:
    commands:
      - description: "Test session orchestration with all backends"  # CORRECTED: Include all backends
        command: "cd services/agent-engine && pytest tests/test_session_orchestration.py -v"
        expected: "All tests pass including VertexAI backend tests"
        
      - description: "Test session creation with memory backend"
        command: |
          cd services/agent-engine && python -c "
          from src.core.session import SessionOrchestrator, MemoryBackend
          backend = MemoryBackend()
          orchestrator = SessionOrchestrator(backend=backend)
          import asyncio
          async def test():
              session = await orchestrator.create_session('user1', 'test_app')
              print(f'Created session: {session.session_id}')
          asyncio.run(test())
          "
        expected: "Session created successfully with memory backend"
        
      - description: "Test VertexAI backend integration"  # ADDED: VertexAI testing
        command: |
          cd services/agent-engine && python -c "
          from src.core.session import VertexBackend, SessionMetadata
          import asyncio
          async def test():
              # Test with mock/test project
              backend = VertexBackend(project_id='test-project')
              print('VertexAI backend initialized successfully')
          asyncio.run(test())
          "
        expected: "VertexAI backend initialized without errors"
        
      - description: "Test session synchronization"  # ADDED: Synchronization testing
        command: |
          cd services/agent-engine && python -c "
          from src.core.session import SessionSynchronizer, MemoryBackend, RedisBackend
          import asyncio
          async def test():
              primary = MemoryBackend()
              secondary = MemoryBackend()  # Mock redis for test
              synchronizer = SessionSynchronizer(primary, secondary)
              print('Session synchronizer created successfully')
          asyncio.run(test())
          "
        expected: "Session synchronizer initialized successfully"
        
      - description: "Test session analytics"  # ADDED: Analytics testing
        command: |
          cd services/agent-engine && python -c "
          from src.core.session import SessionAnalytics
          import asyncio
          async def test():
              analytics = SessionAnalytics()
              await analytics.track_session_event('test_session', 'create', {'test': 'data'})
              metrics = analytics.get_global_analytics()
              print(f'Analytics working: {metrics}')
          asyncio.run(test())
          "
        expected: "Analytics tracking and metrics collection working"
        
    success_criteria:
      - "SessionOrchestrator implemented with multi-backend support"
      - "All three backends working (Memory, Redis, VertexAI)"  # CORRECTED: Include all backends
      - "VertexAI enterprise backend fully integrated"  # ADDED: Enterprise requirement
      - "Session forking and merging functional across all backends"  # CORRECTED: Include all backends
      - "Session-scoped agent instances working"  # ADDED: From masterplan
      - "Session synchronization between backends operational"  # ADDED: From masterplan
      - "Database integration for audit trails implemented"  # ADDED: From masterplan
      - "Analytics and metrics collection functional"  # ADDED: From masterplan
      - "Lifecycle hooks and event system tested"
      - "All tests pass including enterprise features"  # CORRECTED: Include enterprise
      
  dependencies:
    required_before:
      - task: "r1-t01"
        reason: "Need project setup"
      - task: "r2-t05"
        reason: "Need runner integration for session execution"