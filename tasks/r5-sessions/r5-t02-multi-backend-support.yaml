task:
  id: "r5-t02-multi-backend-support"
  name: "Implement Multi-Backend Session Support"
  description: "Extend ADK session system with additional backend implementations including database persistence and enterprise features"
  complexity: "medium"
  estimated_hours: 4  # CORRECTED: Increased from 3 to account for ADK integration complexity
  
  context:
    why: "Different backends provide various trade-offs for performance, durability, and enterprise features while maintaining ADK compatibility"
    architectural_role: "Extends ADK session orchestration with pluggable backend implementations following SessionService patterns"
    depends_on_tasks: ["r5-t01", "r1-t04"]
    enables_tasks: ["r5-t04"]
    references:
      masterplan: "@MASTERPLAN.md#session-management"
      architecture: "@memory-bank/architecture.md#session-management"
      adk_docs: "https://google.github.io/adk-docs/sessions/"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/session.py"  # CORRECTED: Moved to match MASTERPLAN architecture
        purpose: "ADK-compliant session orchestration with multi-backend support"
        exports:
          - "SessionOrchestrator: Main session management class per MASTERPLAN"
          - "DatabaseSessionService: ADK-compliant PostgreSQL/Prisma backend"
          - "HybridSessionService: Multi-tier session service"
          - "SessionServiceFactory: Factory for creating ADK session services"
        content_structure: |
          # VERIFIED: ADK imports from official documentation
          from typing import Dict, Any, List, Optional, Tuple, Union
          from datetime import datetime, timedelta
          import logging
          import json
          import asyncio
          from enum import Enum
          import uuid
          
          from pydantic import BaseModel
          # VERIFIED: Core ADK session imports
          from google.adk.sessions import InMemorySessionService, Session
          from google.adk.sessions.base import BaseSessionService  # VERIFIED: ADK base class
          from google.adk.events import Event
          
          # ADDED: Prisma integration per MASTERPLAN
          from ..services.database import DatabaseService
          from ..models.configuration import SessionConfig
          from ..utils.configuration import get_configuration
          
          logger = logging.getLogger(__name__)
          
          class SessionServiceType(str, Enum):
              """Available session service types"""
              MEMORY = "memory"
              REDIS = "redis"
              DATABASE = "database"
              VERTEX = "vertex"
              HYBRID = "hybrid"
          
          # CORRECTED: Follow ADK SessionService pattern instead of custom interface
          class DatabaseSessionService(BaseSessionService):
              """ADK-compliant PostgreSQL/Prisma session service for durability"""
              
              def __init__(self, database_service: DatabaseService):
                  super().__init__()
                  self.db_service = database_service
              
              # VERIFIED: ADK SessionService method signatures
              async def create_session(
                  self,
                  app_name: str,
                  user_id: str,
                  initial_state: Optional[Dict[str, Any]] = None,
                  session_id: Optional[str] = None
              ) -> Session:
                  """Create session in database using Prisma"""
                  if session_id is None:
                      session_id = str(uuid.uuid4())
                  
                  try:
                      # ADDED: Use Prisma models per MASTERPLAN
                      session_data = {
                          "session_id": session_id,
                          "app_name": app_name,
                          "user_id": user_id,
                          "state": initial_state or {},
                          "created_at": datetime.now(),
                          "updated_at": datetime.now(),
                          "is_active": True
                      }
                      
                      await self.db_service.create_session(session_data)
                      
                      # VERIFIED: Return ADK Session object
                      session = Session(
                          id=session_id,
                          app_name=app_name,
                          user_id=user_id,
                          state=initial_state or {},
                          events=[]
                      )
                      
                      logger.info(f"Created database session: {session_id}")
                      return session
                      
                  except Exception as e:
                      logger.error(f"Failed to create database session: {e}")
                      raise
              
              async def get_session(self, session_id: str) -> Optional[Session]:
                  """Get session from database"""
                  try:
                      session_data = await self.db_service.get_session(session_id)
                      if not session_data:
                          return None
                      
                      # VERIFIED: Reconstruct ADK Session object
                      return Session(
                          id=session_data["session_id"],
                          app_name=session_data["app_name"],
                          user_id=session_data["user_id"],
                          state=session_data.get("state", {}),
                          events=session_data.get("events", [])
                      )
                      
                  except Exception as e:
                      logger.error(f"Failed to get database session: {e}")
                      return None
              
              async def update_session(self, session: Session) -> bool:
                  """Update session in database"""
                  try:
                      session_data = {
                          "session_id": session.id,
                          "state": session.state,
                          "events": session.events,
                          "updated_at": datetime.now()
                      }
                      
                      result = await self.db_service.update_session(session.id, session_data)
                      return result is not None
                      
                  except Exception as e:
                      logger.error(f"Failed to update database session: {e}")
                      return False
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from database"""
                  try:
                      result = await self.db_service.delete_session(session_id)
                      return result
                      
                  except Exception as e:
                      logger.error(f"Failed to delete database session: {e}")
                      return False
              
              async def list_sessions(
                  self,
                  app_name: Optional[str] = None,
                  user_id: Optional[str] = None
              ) -> List[Session]:
                  """List sessions from database"""
                  try:
                      sessions_data = await self.db_service.list_sessions(
                          app_name=app_name,
                          user_id=user_id
                      )
                      
                      sessions = []
                      for data in sessions_data:
                          session = Session(
                              id=data["session_id"],
                              app_name=data["app_name"],
                              user_id=data["user_id"],
                              state=data.get("state", {}),
                              events=data.get("events", [])
                          )
                          sessions.append(session)
                      
                      return sessions
                      
                  except Exception as e:
                      logger.error(f"Failed to list database sessions: {e}")
                      return []
          
          class HybridSessionService(BaseSessionService):
              """Multi-tier session service with caching and durability"""
              
              def __init__(
                  self,
                  cache_service: BaseSessionService,  # Fast tier (Memory/Redis)
                  persistent_service: BaseSessionService,  # Slow tier (Database)
                  write_through: bool = True,
                  cache_ttl: int = 3600
              ):
                  super().__init__()
                  self.cache = cache_service
                  self.persistent = persistent_service
                  self.write_through = write_through
                  self.cache_ttl = cache_ttl
              
              async def create_session(
                  self,
                  app_name: str,
                  user_id: str,
                  initial_state: Optional[Dict[str, Any]] = None,
                  session_id: Optional[str] = None
              ) -> Session:
                  """Create session in both tiers"""
                  # Create in persistent tier first
                  session = await self.persistent.create_session(
                      app_name, user_id, initial_state, session_id
                  )
                  
                  # Cache if successful
                  if session:
                      try:
                          await self.cache.create_session(
                              app_name, user_id, initial_state, session.id
                          )
                      except Exception as e:
                          logger.warning(f"Failed to cache session {session.id}: {e}")
                  
                  return session
              
              async def get_session(self, session_id: str) -> Optional[Session]:
                  """Get session with cache-first strategy"""
                  # Try cache first
                  try:
                      session = await self.cache.get_session(session_id)
                      if session:
                          logger.debug(f"Session {session_id} found in cache")
                          return session
                  except Exception as e:
                      logger.warning(f"Cache lookup failed for {session_id}: {e}")
                  
                  # Fall back to persistent
                  session = await self.persistent.get_session(session_id)
                  
                  if session:
                      # Populate cache
                      try:
                          await self.cache.create_session(
                              session.app_name, session.user_id, session.state, session.id
                          )
                          logger.debug(f"Session {session_id} loaded from persistent store")
                      except Exception as e:
                          logger.warning(f"Failed to populate cache for {session_id}: {e}")
                  
                  return session
              
              async def update_session(self, session: Session) -> bool:
                  """Update session in both tiers"""
                  results = []
                  
                  # Update cache
                  try:
                      cache_result = await self.cache.update_session(session)
                      results.append(cache_result)
                  except Exception as e:
                      logger.warning(f"Cache update failed for {session.id}: {e}")
                      results.append(False)
                  
                  # Update persistent if write-through
                  if self.write_through:
                      try:
                          persistent_result = await self.persistent.update_session(session)
                          results.append(persistent_result)
                      except Exception as e:
                          logger.error(f"Persistent update failed for {session.id}: {e}")
                          results.append(False)
                  
                  # Return true if at least one succeeded
                  return any(results)
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from both tiers"""
                  results = []
                  
                  # Delete from cache
                  try:
                      cache_result = await self.cache.delete_session(session_id)
                      results.append(cache_result)
                  except Exception as e:
                      logger.warning(f"Cache deletion failed for {session_id}: {e}")
                      results.append(False)
                  
                  # Delete from persistent
                  try:
                      persistent_result = await self.persistent.delete_session(session_id)
                      results.append(persistent_result)
                  except Exception as e:
                      logger.error(f"Persistent deletion failed for {session_id}: {e}")
                      results.append(False)
                  
                  return any(results)
              
              async def list_sessions(
                  self,
                  app_name: Optional[str] = None,
                  user_id: Optional[str] = None
              ) -> List[Session]:
                  """List sessions from persistent tier"""
                  return await self.persistent.list_sessions(app_name, user_id)
          
          class SessionServiceFactory:
              """Factory for creating ADK-compliant session services"""
              
              def __init__(self, database_service: DatabaseService):
                  self.database_service = database_service
                  self.config = get_configuration()
              
              def create_session_service(
                  self,
                  service_type: SessionServiceType,
                  config: Optional[Dict[str, Any]] = None
              ) -> BaseSessionService:
                  """Create session service based on type and configuration"""
                  config = config or {}
                  
                  if service_type == SessionServiceType.MEMORY:
                      # VERIFIED: Use ADK's built-in InMemorySessionService
                      return InMemorySessionService()
                  
                  elif service_type == SessionServiceType.DATABASE:
                      return DatabaseSessionService(self.database_service)
                  
                  elif service_type == SessionServiceType.HYBRID:
                      cache_config = config.get("cache", {"type": "memory"})
                      persistent_config = config.get("persistent", {"type": "database"})
                      
                      cache_service = self.create_session_service(
                          SessionServiceType(cache_config.get("type", "memory")),
                          cache_config
                      )
                      
                      persistent_service = self.create_session_service(
                          SessionServiceType(persistent_config.get("type", "database")),
                          persistent_config
                      )
                      
                      return HybridSessionService(
                          cache_service,
                          persistent_service,
                          write_through=config.get("write_through", True),
                          cache_ttl=config.get("cache_ttl", 3600)
                      )
                  
                  # CORRECTED: Remove non-functional VertexBackend placeholder
                  elif service_type == SessionServiceType.VERTEX:
                      # TODO: Implement when Vertex AI session requirements are defined
                      raise NotImplementedError(
                          "Vertex AI session service not yet implemented. "
                          "Use DATABASE or HYBRID for enterprise persistence."
                      )
                  
                  else:
                      raise ValueError(f"Unknown session service type: {service_type}")
          
          # ADDED: SessionOrchestrator per MASTERPLAN pattern
          class SessionOrchestrator:
              """Universal session management with multiple backends per MASTERPLAN"""
              
              def __init__(self, database_service: DatabaseService):
                  self.database_service = database_service
                  self.factory = SessionServiceFactory(database_service)
                  self.config = get_configuration()
              
              def create_session_service(self, config: Dict[str, Any]) -> BaseSessionService:
                  """Create session service with specified configuration"""
                  backend = config.get("persistence", "memory")
                  service_type = SessionServiceType(backend.lower())
                  
                  return self.factory.create_session_service(service_type, config)
              
              async def create_session(self, config: Dict[str, Any]) -> str:
                  """Create session with specified backend configuration"""
                  session_service = self.create_session_service(config)
                  
                  session = await session_service.create_session(
                      app_name=config["app_name"],
                      user_id=config["user_id"],
                      initial_state=config.get("initial_state", {}),
                      session_id=config.get("session_id")
                  )
                  
                  return session.id
              
              async def get_session_service_for_session(
                  self, 
                  session_id: str
              ) -> Optional[BaseSessionService]:
                  """Get appropriate session service for an existing session"""
                  # Try different backends to find the session
                  for service_type in [SessionServiceType.MEMORY, SessionServiceType.DATABASE]:
                      try:
                          service = self.factory.create_session_service(service_type)
                          session = await service.get_session(session_id)
                          if session:
                              return service
                      except Exception as e:
                          logger.debug(f"Session {session_id} not found in {service_type}: {e}")
                  
                  return None
      
      - path: "services/agent-engine/tests/test_session_backends.py"
        purpose: "Tests for ADK-compliant multi-backend session support"
        test_categories:
          - "DatabaseSessionService ADK compliance"
          - "HybridSessionService functionality"
          - "SessionServiceFactory creation"
          - "SessionOrchestrator integration"
          - "Failover and error scenarios"
          - "Session forking and state management"
    
    modifies:
      # ADDED: Integration points per MASTERPLAN
      - path: "services/agent-engine/src/services/database.py"
        purpose: "Add session-specific database operations"
        changes:
          - "Add session CRUD operations using Prisma"
          - "Add session querying and filtering methods"
          - "Add session event storage and retrieval"
    
    uses_from_previous:
      - source: "r5-t01"
        component: "Base session management patterns"
        usage: "Foundation for multi-backend implementation"
      - source: "r1-t04"
        component: "Database setup and Prisma integration"
        usage: "Database backend persistence layer"
    
  implementation_steps:
    - step: "Create DatabaseSessionService"
      implementation_notes: |
        # CORRECTED: ADK-compliant implementation
        - Extend BaseSessionService from ADK
        - Use Prisma ORM instead of raw SQL
        - Implement all required SessionService methods
        - Add proper error handling and logging
        
    - step: "Implement HybridSessionService"
      implementation_notes: |
        - Multi-tier caching with write-through/write-back options
        - Cache-first read strategy with fallback
        - Async error handling for tier failures
        - Performance monitoring hooks
        
    - step: "Build SessionServiceFactory"
      implementation_notes: |
        - Configuration-driven service creation
        - Dependency injection for database service
        - Validation of service configurations
        - Support for environment-based defaults
        
    - step: "Create SessionOrchestrator"
      implementation_notes: |
        # ADDED: Per MASTERPLAN architecture
        - Implement universal session management interface
        - Support dynamic backend selection
        - Session discovery across backends
        - Integration with ADK Runner patterns
        
    - step: "Add Database Integration"
      implementation_notes: |
        # ADDED: Missing Prisma integration
        - Extend DatabaseService with session operations
        - Add Prisma schema for session storage
        - Implement session querying and indexing
        - Add audit trail capabilities
        
  validation:
    commands:
      - description: "Test ADK session service compliance"
        command: "cd services/agent-engine && pytest tests/test_session_backends.py::test_adk_compliance -v"
        expected: "All ADK interface tests pass"
        
      - description: "Test multi-backend functionality"
        command: "cd services/agent-engine && pytest tests/test_session_backends.py::test_multi_backend -v"
        expected: "All backend switching tests pass"
        
      - description: "Test session orchestration"
        command: "cd services/agent-engine && pytest tests/test_session_backends.py::test_orchestration -v"
        expected: "SessionOrchestrator tests pass"
        
      - description: "Run all session backend tests"
        command: "cd services/agent-engine && pytest tests/test_session_backends.py -v"
        expected: "All tests pass with >85% coverage"
        
    success_criteria:
      - "DatabaseSessionService implements all ADK SessionService methods"
      - "HybridSessionService provides cache-through functionality"
      - "SessionOrchestrator matches MASTERPLAN patterns"
      - "All services integrate with existing ADK workflow"
      - "Prisma integration working for session persistence"
      - "All tests pass with comprehensive coverage"
      
  dependencies:
    required_before:
      - task: "r5-t01"
        reason: "Need base session management foundation"
      - task: "r1-t04"
        reason: "Need database infrastructure and Prisma setup"
    
    integrates_with:
      - component: "ADK InMemoryRunner"
        reason: "Session services must work with ADK runtime"
      - component: "Configuration system"
        reason: "Backend selection via environment configuration"