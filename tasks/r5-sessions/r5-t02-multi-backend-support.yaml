task:
  id: "r5-t02-multi-backend-support"
  name: "Implement Multi-Backend Session Support"
  description: "Create additional session backends including Vertex AI integration and database persistence"
  complexity: "medium"
  estimated_hours: 3
  
  context:
    why: "Different backends provide various trade-offs for performance, durability, and enterprise features"
    architectural_role: "Extends session system with pluggable backend implementations"
    depends_on_tasks: ["r5-t01", "r1-t04"]
    enables_tasks: ["r5-t04"]
    references:
      masterplan: "@MASTERPLAN.md#session-management"
      architecture: "@memory-bank/architecture.md#session-management"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/session_backends.py"
        purpose: "Additional session backend implementations"
        exports:
          - "DatabaseBackend: PostgreSQL session backend"
          - "VertexBackend: Vertex AI session backend"
          - "HybridBackend: Multi-tier session backend"
          - "BackendFactory: Backend creation factory"
        content_structure: |
          from typing import Dict, Any, List, Optional, Tuple
          from datetime import datetime, timedelta
          import logging
          import json
          import asyncio
          from enum import Enum
          
          from pydantic import BaseModel
          from sqlalchemy.ext.asyncio import AsyncSession
          from google.cloud import aiplatform
          
          from .session import SessionBackend, SessionMetadata, SessionState
          from ..db.models import SessionRecord, SessionStateRecord
          
          logger = logging.getLogger(__name__)
          
          class BackendType(str, Enum):
              """Available backend types"""
              MEMORY = "memory"
              REDIS = "redis"
              DATABASE = "database"
              VERTEX = "vertex"
              HYBRID = "hybrid"
          
          class DatabaseBackend(SessionBackend):
              """PostgreSQL/Prisma session backend for durability"""
              
              def __init__(self, db_session_factory):
                  self.db_session_factory = db_session_factory
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in database"""
                  async with self.db_session_factory() as db:
                      try:
                          # Create session record
                          session_record = SessionRecord(
                              session_id=metadata.session_id,
                              user_id=metadata.user_id,
                              app_name=metadata.app_name,
                              metadata_json=json.dumps(metadata.model_dump(mode='json'), default=str),
                              created_at=metadata.created_at,
                              updated_at=metadata.updated_at,
                              is_active=metadata.is_active,
                              parent_session_id=metadata.parent_session_id
                          )
                          db.add(session_record)
                          
                          # Create state record
                          state = initial_state or SessionState()
                          state_record = SessionStateRecord(
                              session_id=metadata.session_id,
                              state_json=json.dumps(state.model_dump(mode='json'), default=str),
                              conversation_history=json.dumps(state.conversation_history),
                              context=json.dumps(state.context),
                              variables=json.dumps(state.variables)
                          )
                          db.add(state_record)
                          
                          await db.commit()
                          logger.info(f"Created database session: {metadata.session_id}")
                          return metadata.session_id
                          
                      except Exception as e:
                          await db.rollback()
                          logger.error(f"Failed to create database session: {e}")
                          raise
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[Tuple[SessionMetadata, SessionState]]:
                  """Get session from database"""
                  async with self.db_session_factory() as db:
                      try:
                          # Query session and state
                          result = await db.execute(
                              "SELECT s.*, st.state_json FROM sessions s "
                              "JOIN session_states st ON s.session_id = st.session_id "
                              "WHERE s.session_id = :session_id",
                              {"session_id": session_id}
                          )
                          row = result.fetchone()
                          
                          if row:
                              metadata = SessionMetadata(**json.loads(row.metadata_json))
                              state = SessionState(**json.loads(row.state_json))
                              return (metadata, state)
                          
                          return None
                          
                      except Exception as e:
                          logger.error(f"Failed to get database session: {e}")
                          return None
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in database"""
                  async with self.db_session_factory() as db:
                      try:
                          # Update session metadata if provided
                          if metadata_update:
                              await db.execute(
                                  "UPDATE sessions SET updated_at = :updated_at, "
                                  "metadata_json = :metadata_json WHERE session_id = :session_id",
                                  {
                                      "session_id": session_id,
                                      "updated_at": datetime.now(),
                                      "metadata_json": json.dumps(metadata_update, default=str)
                                  }
                              )
                          
                          # Update state
                          await db.execute(
                              "UPDATE session_states SET state_json = :state_json, "
                              "conversation_history = :history, context = :context, "
                              "variables = :variables WHERE session_id = :session_id",
                              {
                                  "session_id": session_id,
                                  "state_json": json.dumps(state.model_dump(mode='json'), default=str),
                                  "history": json.dumps(state.conversation_history),
                                  "context": json.dumps(state.context),
                                  "variables": json.dumps(state.variables)
                              }
                          )
                          
                          await db.commit()
                          return True
                          
                      except Exception as e:
                          await db.rollback()
                          logger.error(f"Failed to update database session: {e}")
                          return False
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from database"""
                  async with self.db_session_factory() as db:
                      try:
                          # Delete state first (foreign key)
                          await db.execute(
                              "DELETE FROM session_states WHERE session_id = :session_id",
                              {"session_id": session_id}
                          )
                          
                          # Delete session
                          result = await db.execute(
                              "DELETE FROM sessions WHERE session_id = :session_id",
                              {"session_id": session_id}
                          )
                          
                          await db.commit()
                          return result.rowcount > 0
                          
                      except Exception as e:
                          await db.rollback()
                          logger.error(f"Failed to delete database session: {e}")
                          return False
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from database"""
                  async with self.db_session_factory() as db:
                      try:
                          query = "SELECT metadata_json FROM sessions WHERE 1=1"
                          params = {}
                          
                          if user_id:
                              query += " AND user_id = :user_id"
                              params["user_id"] = user_id
                          
                          if app_name:
                              query += " AND app_name = :app_name"
                              params["app_name"] = app_name
                          
                          if active_only:
                              query += " AND is_active = true"
                          
                          result = await db.execute(query, params)
                          
                          sessions = []
                          for row in result:
                              metadata = SessionMetadata(**json.loads(row.metadata_json))
                              sessions.append(metadata)
                          
                          return sessions
                          
                      except Exception as e:
                          logger.error(f"Failed to list database sessions: {e}")
                          return []
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in database"""
                  session_data = await self.get_session(source_session_id)
                  if not session_data:
                      return None
                  
                  source_metadata, source_state = session_data
                  
                  # Create forked metadata
                  new_metadata = SessionMetadata(
                      session_id=new_session_id,
                      user_id=source_metadata.user_id,
                      app_name=source_metadata.app_name,
                      parent_session_id=source_session_id,
                      tags=source_metadata.tags.copy(),
                      config=source_metadata.config.copy()
                  )
                  
                  # Copy state
                  new_state = SessionState(
                      conversation_history=source_state.conversation_history.copy(),
                      context=source_state.context.copy(),
                      variables=source_state.variables.copy()
                  )
                  
                  await self.create_session(new_metadata, new_state)
                  return new_session_id
          
          class VertexBackend(SessionBackend):
              """Vertex AI session backend for enterprise features"""
              
              def __init__(
                  self,
                  project_id: str,
                  location: str = "us-central1",
                  dataset_id: Optional[str] = None
              ):
                  self.project_id = project_id
                  self.location = location
                  self.dataset_id = dataset_id
                  aiplatform.init(project=project_id, location=location)
                  
                  # Note: This is a simplified implementation
                  # Real Vertex AI integration would use Vertex AI Feature Store
                  # or Vertex AI Matching Engine for session storage
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in Vertex AI"""
                  try:
                      # In a real implementation, this would:
                      # 1. Create entity in Feature Store
                      # 2. Store conversation in Vertex AI Search
                      # 3. Use Matching Engine for similarity search
                      
                      logger.info(f"Created Vertex AI session: {metadata.session_id}")
                      return metadata.session_id
                      
                  except Exception as e:
                      logger.error(f"Failed to create Vertex AI session: {e}")
                      raise
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[Tuple[SessionMetadata, SessionState]]:
                  """Get session from Vertex AI"""
                  # Simplified implementation
                  return None
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in Vertex AI"""
                  # Simplified implementation
                  return True
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from Vertex AI"""
                  # Simplified implementation
                  return True
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from Vertex AI"""
                  # Simplified implementation
                  return []
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in Vertex AI"""
                  # Simplified implementation
                  return new_session_id
          
          class HybridBackend(SessionBackend):
              """Multi-tier session backend with caching and durability"""
              
              def __init__(
                  self,
                  cache_backend: SessionBackend,  # Fast tier (Memory/Redis)
                  persistent_backend: SessionBackend,  # Slow tier (Database/Vertex)
                  write_through: bool = True,
                  cache_ttl: int = 3600
              ):
                  self.cache = cache_backend
                  self.persistent = persistent_backend
                  self.write_through = write_through
                  self.cache_ttl = cache_ttl
              
              async def create_session(
                  self,
                  metadata: SessionMetadata,
                  initial_state: Optional[SessionState] = None
              ) -> str:
                  """Create session in both tiers"""
                  # Create in persistent tier first
                  session_id = await self.persistent.create_session(metadata, initial_state)
                  
                  # Cache if successful
                  if session_id:
                      await self.cache.create_session(metadata, initial_state)
                  
                  return session_id
              
              async def get_session(
                  self,
                  session_id: str
              ) -> Optional[Tuple[SessionMetadata, SessionState]]:
                  """Get session with cache-first strategy"""
                  # Try cache first
                  session_data = await self.cache.get_session(session_id)
                  
                  if session_data:
                      logger.debug(f"Session {session_id} found in cache")
                      return session_data
                  
                  # Fall back to persistent
                  session_data = await self.persistent.get_session(session_id)
                  
                  if session_data:
                      # Populate cache
                      metadata, state = session_data
                      await self.cache.create_session(metadata, state)
                      logger.debug(f"Session {session_id} loaded from persistent store")
                  
                  return session_data
              
              async def update_session(
                  self,
                  session_id: str,
                  state: SessionState,
                  metadata_update: Optional[Dict] = None
              ) -> bool:
                  """Update session in both tiers"""
                  tasks = []
                  
                  # Update cache
                  tasks.append(self.cache.update_session(session_id, state, metadata_update))
                  
                  # Update persistent if write-through
                  if self.write_through:
                      tasks.append(self.persistent.update_session(session_id, state, metadata_update))
                  
                  results = await asyncio.gather(*tasks, return_exceptions=True)
                  
                  # Return true if at least one succeeded
                  return any(r is True for r in results if not isinstance(r, Exception))
              
              async def delete_session(self, session_id: str) -> bool:
                  """Delete session from both tiers"""
                  tasks = [
                      self.cache.delete_session(session_id),
                      self.persistent.delete_session(session_id)
                  ]
                  
                  results = await asyncio.gather(*tasks, return_exceptions=True)
                  return any(r is True for r in results if not isinstance(r, Exception))
              
              async def list_sessions(
                  self,
                  user_id: Optional[str] = None,
                  app_name: Optional[str] = None,
                  active_only: bool = True
              ) -> List[SessionMetadata]:
                  """List sessions from persistent tier"""
                  return await self.persistent.list_sessions(user_id, app_name, active_only)
              
              async def fork_session(
                  self,
                  source_session_id: str,
                  new_session_id: str
              ) -> Optional[str]:
                  """Fork session in both tiers"""
                  # Fork in persistent first
                  result = await self.persistent.fork_session(source_session_id, new_session_id)
                  
                  if result:
                      # Fork in cache
                      await self.cache.fork_session(source_session_id, new_session_id)
                  
                  return result
          
          class BackendFactory:
              """Factory for creating session backends"""
              
              @staticmethod
              def create_backend(
                  backend_type: BackendType,
                  config: Dict[str, Any]
              ) -> SessionBackend:
                  """Create backend based on type and configuration"""
                  
                  if backend_type == BackendType.MEMORY:
                      from .session import MemoryBackend
                      return MemoryBackend()
                  
                  elif backend_type == BackendType.REDIS:
                      from .session import RedisBackend
                      import redis.asyncio as redis
                      
                      redis_client = redis.Redis(
                          host=config.get("host", "localhost"),
                          port=config.get("port", 6379),
                          db=config.get("db", 0),
                          decode_responses=True
                      )
                      return RedisBackend(
                          redis_client,
                          prefix=config.get("prefix", "session:"),
                          default_ttl=config.get("ttl", 86400)
                      )
                  
                  elif backend_type == BackendType.DATABASE:
                      db_session_factory = config.get("db_session_factory")
                      if not db_session_factory:
                          raise ValueError("Database backend requires db_session_factory")
                      return DatabaseBackend(db_session_factory)
                  
                  elif backend_type == BackendType.VERTEX:
                      return VertexBackend(
                          project_id=config.get("project_id"),
                          location=config.get("location", "us-central1"),
                          dataset_id=config.get("dataset_id")
                      )
                  
                  elif backend_type == BackendType.HYBRID:
                      cache_config = config.get("cache", {})
                      persistent_config = config.get("persistent", {})
                      
                      cache_backend = BackendFactory.create_backend(
                          BackendType[cache_config.get("type", "MEMORY").upper()],
                          cache_config
                      )
                      
                      persistent_backend = BackendFactory.create_backend(
                          BackendType[persistent_config.get("type", "DATABASE").upper()],
                          persistent_config
                      )
                      
                      return HybridBackend(
                          cache_backend,
                          persistent_backend,
                          write_through=config.get("write_through", True),
                          cache_ttl=config.get("cache_ttl", 3600)
                      )
                  
                  else:
                      raise ValueError(f"Unknown backend type: {backend_type}")
      
      - path: "services/agent-engine/tests/test_session_backends.py"
        purpose: "Tests for multi-backend support"
        test_categories:
          - "Database backend"
          - "Vertex backend"
          - "Hybrid backend"
          - "Backend factory"
          - "Failover scenarios"
    
    uses_from_previous:
      - source: "r5-t01"
        component: "SessionBackend interface"
        usage: "Base interface implementation"
      - source: "r1-t04"
        component: "Database setup"
        usage: "Database backend storage"
    
  implementation_steps:
    - step: "Create DatabaseBackend"
      implementation_notes: |
        - Prisma integration
        - Transaction support
        - Query optimization
        
    - step: "Implement VertexBackend"
      implementation_notes: |
        - Vertex AI integration
        - Feature Store usage
        - Enterprise features
        
    - step: "Build HybridBackend"
      implementation_notes: |
        - Cache-through pattern
        - Write-through option
        - Failover handling
        
    - step: "Create BackendFactory"
      implementation_notes: |
        - Dynamic backend creation
        - Configuration-driven
        - Validation logic
        
  validation:
    commands:
      - description: "Test multi-backend support"
        command: "cd services/agent-engine && pytest tests/test_session_backends.py -v"
        expected: "All tests pass"
        
    success_criteria:
      - "Database backend functional"
      - "Hybrid backend working"
      - "Factory creates all types"
      - "All tests pass"
      
  dependencies:
    required_before:
      - task: "r5-t01"
        reason: "Need base session system"
      - task: "r1-t04"
        reason: "Need database for persistence"