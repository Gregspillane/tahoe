task:
  id: "r5-t03-session-recovery"
  name: "Implement Session Recovery and Resilience"
  description: "Create ADK-native session recovery mechanisms leveraging built-in session persistence and state management"
  complexity: "medium"
  estimated_hours: 3
  
  context:
    why: "Session recovery ensures continuity of interactions despite failures and enables debugging capabilities using ADK's native session infrastructure"
    architectural_role: "Provides resilience and debugging features for session management through ADK session services"
    depends_on_tasks: ["r5-t01"]
    enables_tasks: ["r5-t04"]
    references:
      masterplan: "@MASTERPLAN.md#session-management"
      architecture: "@memory-bank/architecture.md#error-recovery"
      adk_docs: "https://google.github.io/adk-docs/sessions/"
    
  implementation:
    creates:
      - path: "services/agent-engine/src/core/session_recovery.py"
        purpose: "ADK-native session recovery and resilience implementation"
        exports:
          - "SessionRecoveryManager: Main recovery coordinator using ADK session services"
          - "SessionCheckpoint: ADK session state snapshot model"
          - "RecoveryStrategy: Recovery strategy interface"
          - "StateBasedRecovery: Recovery using ADK state persistence"
          - "SessionReplay: Session replay using ADK event history"
        content_structure: |
          # CORRECTED: Use ADK-native imports and remove custom serialization
          from typing import Dict, Any, List, Optional, Callable, Tuple
          from datetime import datetime, timedelta
          from pydantic import BaseModel, Field
          import logging
          import asyncio
          from enum import Enum
          from abc import ABC, abstractmethod
          
          # VERIFIED: ADK official imports from documentation
          from google.adk.sessions import SessionService, Session
          from google.adk.runners import InMemoryRunner
          from google.adk.events import Event
          
          # ADDED: Integration with existing session orchestration
          from .session import SessionOrchestrator
          
          logger = logging.getLogger(__name__)
          
          class CheckpointType(str, Enum):
              """Types of session checkpoints"""
              MANUAL = "manual"
              AUTOMATIC = "automatic"
              ERROR = "error"
              MILESTONE = "milestone"
          
          # CORRECTED: Use ADK Session objects instead of custom state models
          class SessionCheckpoint(BaseModel):
              """ADK session checkpoint for recovery"""
              checkpoint_id: str
              session_id: str
              checkpoint_type: CheckpointType
              timestamp: datetime = Field(default_factory=datetime.now)
              # VERIFIED: ADK Session contains state and events natively
              session_snapshot: Dict[str, Any] = Field(default_factory=dict)  # Serialized ADK Session
              event_count: int = 0  # Number of events at checkpoint time
              description: Optional[str] = None
              recoverable: bool = True
              expires_at: Optional[datetime] = None
          
          class RecoveryResult(BaseModel):
              """Result of ADK session recovery operation"""
              success: bool
              session_id: str
              checkpoint_id: Optional[str] = None
              recovered_at: datetime = Field(default_factory=datetime.now)
              events_recovered: int = 0  # CORRECTED: ADK uses events, not messages
              state_recovered: bool = False
              error: Optional[str] = None
          
          class RecoveryStrategy(ABC):
              """Abstract recovery strategy"""
              
              @abstractmethod
              async def recover(
                  self,
                  checkpoint: SessionCheckpoint,
                  target_session_id: Optional[str] = None
              ) -> RecoveryResult:
                  """Recover session from checkpoint"""
                  pass
              
              @abstractmethod
              def can_recover(self, checkpoint: SessionCheckpoint) -> bool:
                  """Check if recovery is possible"""
                  pass
          
          # CORRECTED: ADK-native recovery strategy using SessionService
          class StateBasedRecovery(RecoveryStrategy):
              """ADK state-based recovery strategy"""
              
              def __init__(self, session_orchestrator: SessionOrchestrator):
                  self.orchestrator = session_orchestrator
              
              async def recover(
                  self,
                  checkpoint: SessionCheckpoint,
                  target_session_id: Optional[str] = None
              ) -> RecoveryResult:
                  """Recover session using ADK session services"""
                  try:
                      target_id = target_session_id or checkpoint.session_id
                      
                      # VERIFIED: Use ADK session creation pattern from docs
                      session_config = {
                          "session_id": target_id,
                          "app_name": checkpoint.session_snapshot.get("app_name", "agent_engine"),
                          "user_id": checkpoint.session_snapshot.get("user_id", "system"),
                          "initial_state": checkpoint.session_snapshot.get("state", {}),
                          "persistence": checkpoint.session_snapshot.get("persistence", "memory")
                      }
                      
                      # Create session through orchestrator using ADK patterns
                      recovered_session_id = await self.orchestrator.create_session(session_config)
                      
                      return RecoveryResult(
                          success=True,
                          session_id=recovered_session_id,
                          checkpoint_id=checkpoint.checkpoint_id,
                          events_recovered=checkpoint.event_count,
                          state_recovered=True
                      )
                      
                  except Exception as e:
                      logger.error(f"ADK session recovery failed: {e}")
                      return RecoveryResult(
                          success=False,
                          session_id=target_session_id or checkpoint.session_id,
                          error=str(e)
                      )
              
              def can_recover(self, checkpoint: SessionCheckpoint) -> bool:
                  """Check if full recovery is possible"""
                  if not checkpoint.recoverable:
                      return False
                  if checkpoint.expires_at and checkpoint.expires_at < datetime.now():
                      return False
                  return True
          
          # ADDED: Simplified recovery that merges with existing sessions
          class EventBasedRecovery(RecoveryStrategy):
              """ADK event-based recovery strategy"""
              
              def __init__(self, session_orchestrator: SessionOrchestrator):
                  self.orchestrator = session_orchestrator
              
              async def recover(
                  self,
                  checkpoint: SessionCheckpoint,
                  target_session_id: Optional[str] = None
              ) -> RecoveryResult:
                  """Recover using ADK event history patterns"""
                  try:
                      target_id = target_session_id or checkpoint.session_id
                      
                      # VERIFIED: ADK get_session pattern from documentation
                      session_config = {
                          "session_id": target_id,
                          "app_name": checkpoint.session_snapshot.get("app_name", "agent_engine"),
                          "user_id": checkpoint.session_snapshot.get("user_id", "system"),
                          "persistence": checkpoint.session_snapshot.get("persistence", "memory")
                      }
                      
                      # Try to get existing session or create new one
                      try:
                          session_id = await self.orchestrator.get_session(target_id)
                          if not session_id:
                              session_id = await self.orchestrator.create_session(session_config)
                      except:
                          session_id = await self.orchestrator.create_session(session_config)
                      
                      return RecoveryResult(
                          success=True,
                          session_id=session_id,
                          checkpoint_id=checkpoint.checkpoint_id,
                          events_recovered=checkpoint.event_count,
                          state_recovered=True
                      )
                      
                  except Exception as e:
                      logger.error(f"ADK event-based recovery failed: {e}")
                      return RecoveryResult(
                          success=False,
                          session_id=target_session_id or checkpoint.session_id,
                          error=str(e)
                      )
              
              def can_recover(self, checkpoint: SessionCheckpoint) -> bool:
                  """Check if event-based recovery is possible"""
                  return checkpoint.session_snapshot is not None
          
          # CORRECTED: Use ADK session services instead of custom storage
          class CheckpointManager:
              """Manages ADK session checkpoints"""
              
              def __init__(self, session_orchestrator: SessionOrchestrator):
                  self.orchestrator = session_orchestrator
                  self.checkpoints: Dict[str, List[SessionCheckpoint]] = {}
                  self.auto_checkpoint_interval = 300  # 5 minutes
                  self.max_checkpoints_per_session = 10
              
              async def create_checkpoint(
                  self,
                  session_id: str,
                  checkpoint_type: CheckpointType = CheckpointType.MANUAL,
                  description: Optional[str] = None,
                  ttl_hours: int = 24
              ) -> SessionCheckpoint:
                  """Create ADK session checkpoint"""
                  from uuid import uuid4
                  
                  # CORRECTED: Get ADK session through orchestrator
                  try:
                      # Get ADK session data through orchestrator
                      session_data = await self.orchestrator.get_session_data(session_id)
                      if not session_data:
                          raise ValueError(f"Session {session_id} not found")
                      
                      checkpoint = SessionCheckpoint(
                          checkpoint_id=f"cp_{uuid4().hex[:12]}",
                          session_id=session_id,
                          checkpoint_type=checkpoint_type,
                          session_snapshot=session_data,  # VERIFIED: ADK session serialization
                          event_count=session_data.get("event_count", 0),
                          description=description,
                          expires_at=datetime.now() + timedelta(hours=ttl_hours)
                      )
                      
                      # Store checkpoint metadata
                      await self._store_checkpoint(checkpoint)
                      
                      # Track in memory
                      if session_id not in self.checkpoints:
                          self.checkpoints[session_id] = []
                      
                      self.checkpoints[session_id].append(checkpoint)
                      
                      # Limit checkpoints per session
                      await self._cleanup_old_checkpoints(session_id)
                      
                      logger.info(f"Created ADK checkpoint {checkpoint.checkpoint_id} for session {session_id}")
                      return checkpoint
                      
                  except Exception as e:
                      logger.error(f"Failed to create checkpoint for session {session_id}: {e}")
                      raise
              
              async def get_checkpoint(
                  self,
                  checkpoint_id: str
              ) -> Optional[SessionCheckpoint]:
                  """Get specific checkpoint"""
                  # CORRECTED: Use orchestrator storage instead of custom backend
                  try:
                      checkpoint_data = await self.orchestrator.get_checkpoint_data(checkpoint_id)
                      if checkpoint_data:
                          return SessionCheckpoint(**checkpoint_data)
                      return None
                  except Exception as e:
                      logger.error(f"Failed to get checkpoint {checkpoint_id}: {e}")
                      return None
              
              async def list_checkpoints(
                  self,
                  session_id: str,
                  checkpoint_type: Optional[CheckpointType] = None
              ) -> List[SessionCheckpoint]:
                  """List session checkpoints"""
                  checkpoints = self.checkpoints.get(session_id, [])
                  
                  # Filter by type if specified
                  if checkpoint_type:
                      checkpoints = [cp for cp in checkpoints if cp.checkpoint_type == checkpoint_type]
                  
                  # Filter out expired
                  now = datetime.now()
                  checkpoints = [
                      cp for cp in checkpoints
                      if not cp.expires_at or cp.expires_at > now
                  ]
                  
                  return sorted(checkpoints, key=lambda x: x.timestamp, reverse=True)
              
              async def delete_checkpoint(self, checkpoint_id: str) -> bool:
                  """Delete checkpoint"""
                  # CORRECTED: Use orchestrator for checkpoint deletion
                  try:
                      return await self.orchestrator.delete_checkpoint(checkpoint_id)
                  except Exception as e:
                      logger.error(f"Failed to delete checkpoint {checkpoint_id}: {e}")
                      return False
              
              async def _store_checkpoint(self, checkpoint: SessionCheckpoint):
                  """Store checkpoint using orchestrator"""
                  # CORRECTED: Use orchestrator storage instead of custom backend
                  try:
                      await self.orchestrator.store_checkpoint(
                          checkpoint.checkpoint_id,
                          checkpoint.model_dump(mode='json')
                      )
                  except Exception as e:
                      logger.error(f"Failed to store checkpoint {checkpoint.checkpoint_id}: {e}")
                      raise
              
              async def _cleanup_old_checkpoints(self, session_id: str):
                  """Clean up old checkpoints for session"""
                  if session_id not in self.checkpoints:
                      return
                  
                  checkpoints = self.checkpoints[session_id]
                  
                  # Keep only recent checkpoints
                  if len(checkpoints) > self.max_checkpoints_per_session:
                      # Sort by timestamp
                      checkpoints.sort(key=lambda x: x.timestamp)
                      
                      # Remove oldest
                      to_remove = checkpoints[:len(checkpoints) - self.max_checkpoints_per_session]
                      for cp in to_remove:
                          await self.delete_checkpoint(cp.checkpoint_id)
                          checkpoints.remove(cp)
          
          # CORRECTED: ADK-native auto recovery
          class AutoRecovery:
              """Automatic ADK session recovery handler"""
              
              def __init__(
                  self,
                  checkpoint_manager: CheckpointManager,
                  recovery_strategy: RecoveryStrategy
              ):
                  self.checkpoint_manager = checkpoint_manager
                  self.recovery_strategy = recovery_strategy
                  self.recovery_attempts: Dict[str, int] = {}
                  self.max_recovery_attempts = 3
              
              async def handle_failure(
                  self,
                  session_id: str,
                  error: Exception
              ) -> Optional[RecoveryResult]:
                  """Handle ADK session failure with auto-recovery"""
                  logger.error(f"ADK session {session_id} failed: {error}")
                  
                  # Check recovery attempts
                  attempts = self.recovery_attempts.get(session_id, 0)
                  if attempts >= self.max_recovery_attempts:
                      logger.error(f"Max recovery attempts reached for session {session_id}")
                      return None
                  
                  # CORRECTED: Create error checkpoint using session_id
                  try:
                      await self.checkpoint_manager.create_checkpoint(
                          session_id,
                          CheckpointType.ERROR,
                          description=f"Error checkpoint: {str(error)}"
                      )
                  except Exception as checkpoint_error:
                      logger.warning(f"Failed to create error checkpoint: {checkpoint_error}")
                  
                  # Find latest recoverable checkpoint
                  checkpoints = await self.checkpoint_manager.list_checkpoints(session_id)
                  
                  for checkpoint in checkpoints:
                      if self.recovery_strategy.can_recover(checkpoint):
                          # Attempt recovery
                          self.recovery_attempts[session_id] = attempts + 1
                          
                          result = await self.recovery_strategy.recover(checkpoint)
                          
                          if result.success:
                              logger.info(f"Successfully recovered session {session_id}")
                              self.recovery_attempts[session_id] = 0  # Reset counter
                              return result
                  
                  logger.error(f"No recoverable checkpoint found for session {session_id}")
                  return None
              
              def reset_attempts(self, session_id: str):
                  """Reset recovery attempts counter"""
                  if session_id in self.recovery_attempts:
                      del self.recovery_attempts[session_id]
          
          # CORRECTED: ADK event-based session replay
          class SessionReplay:
              """ADK session replay functionality for debugging"""
              
              def __init__(self, session_orchestrator: SessionOrchestrator):
                  self.orchestrator = session_orchestrator
              
              async def replay_session(
                  self,
                  checkpoint: SessionCheckpoint,
                  start_index: int = 0,
                  end_index: Optional[int] = None,
                  speed: float = 1.0
              ) -> AsyncIterator[Dict[str, Any]]:
                  """Replay ADK session events from checkpoint"""
                  # VERIFIED: Use ADK event data from session snapshot
                  events = checkpoint.session_snapshot.get("events", [])
                  replay_events = events[start_index:end_index]
                  
                  for i, event in enumerate(replay_events):
                      # Calculate delay for realistic replay
                      if i > 0 and speed > 0:
                          delay = 1.0 / speed  # Simplified delay calculation
                          await asyncio.sleep(delay)
                      
                      yield {
                          "index": start_index + i,
                          "event": event,
                          "timestamp": event.get("timestamp"),
                          "event_type": event.get("type", "unknown")
                      }
              
              async def replay_to_point(
                  self,
                  session_id: str,
                  target_event_index: int
              ) -> str:
                  """Replay ADK session up to specific event"""
                  # Get latest checkpoint before target
                  checkpoint_manager = CheckpointManager(self.orchestrator)
                  checkpoints = await checkpoint_manager.list_checkpoints(session_id)
                  
                  best_checkpoint = None
                  for cp in checkpoints:
                      if cp.event_count <= target_event_index:
                          best_checkpoint = cp
                          break
                  
                  if not best_checkpoint:
                      raise ValueError(f"No checkpoint found before event {target_event_index}")
                  
                  # CORRECTED: Use ADK-native recovery strategy
                  recovery_strategy = StateBasedRecovery(self.orchestrator)
                  result = await recovery_strategy.recover(
                      best_checkpoint,
                      f"{session_id}_replay"
                  )
                  
                  if not result.success:
                      raise RuntimeError(f"Failed to replay ADK session: {result.error}")
                  
                  # VERIFIED: Return session ID for further ADK session operations
                  return result.session_id
          
          # CORRECTED: Main recovery coordinator using ADK session services
          class SessionRecoveryManager:
              """ADK-native session recovery coordinator"""
              
              def __init__(
                  self,
                  session_orchestrator: SessionOrchestrator,
                  enable_auto_recovery: bool = True
              ):
                  self.orchestrator = session_orchestrator
                  self.checkpoint_manager = CheckpointManager(session_orchestrator)
                  # VERIFIED: Use ADK-native recovery strategies
                  self.strategies = {
                      "state_based": StateBasedRecovery(session_orchestrator),
                      "event_based": EventBasedRecovery(session_orchestrator)
                  }
                  self.auto_recovery = AutoRecovery(
                      self.checkpoint_manager,
                      self.strategies["state_based"]
                  ) if enable_auto_recovery else None
                  self.replay = SessionReplay(session_orchestrator)
              
              async def create_checkpoint(
                  self,
                  session_id: str,
                  checkpoint_type: CheckpointType = CheckpointType.MANUAL,
                  description: Optional[str] = None
              ) -> Optional[SessionCheckpoint]:
                  """Create checkpoint for ADK session"""
                  # CORRECTED: Use checkpoint manager with session_id directly
                  try:
                      return await self.checkpoint_manager.create_checkpoint(
                          session_id,
                          checkpoint_type,
                          description
                      )
                  except Exception as e:
                      logger.error(f"Failed to create checkpoint for session {session_id}: {e}")
                      return None
              
              async def recover_session(
                  self,
                  checkpoint_id: str,
                  strategy: str = "state_based",
                  target_session_id: Optional[str] = None
              ) -> RecoveryResult:
                  """Recover ADK session from checkpoint"""
                  checkpoint = await self.checkpoint_manager.get_checkpoint(checkpoint_id)
                  if not checkpoint:
                      return RecoveryResult(
                          success=False,
                          session_id=target_session_id or "unknown",
                          error=f"Checkpoint {checkpoint_id} not found"
                      )
                  
                  recovery_strategy = self.strategies.get(strategy)
                  if not recovery_strategy:
                      return RecoveryResult(
                          success=False,
                          session_id=checkpoint.session_id,
                          error=f"Unknown recovery strategy: {strategy}"
                      )
                  
                  return await recovery_strategy.recover(checkpoint, target_session_id)
              
              async def handle_session_failure(
                  self,
                  session_id: str,
                  error: Exception
              ) -> Optional[RecoveryResult]:
                  """Handle ADK session failure with recovery"""
                  if self.auto_recovery:
                      return await self.auto_recovery.handle_failure(
                          session_id,
                          error
                      )
                  return None
              
              def get_metrics(self) -> Dict:
                  """Get ADK session recovery metrics"""
                  return {
                      "total_checkpoints": sum(
                          len(cps) for cps in self.checkpoint_manager.checkpoints.values()
                      ),
                      "sessions_with_checkpoints": len(self.checkpoint_manager.checkpoints),
                      "auto_recovery_enabled": self.auto_recovery is not None,
                      "available_strategies": list(self.strategies.keys()),
                      "adk_integration": True
                  }
      
      - path: "services/agent-engine/tests/test_session_recovery.py"
        purpose: "Tests for session recovery"
        test_categories:
          - "Checkpoint creation"
          - "Recovery strategies"
          - "Auto-recovery"
          - "Session replay"
          - "Failure scenarios"
    
    uses_from_previous:
      - source: "r5-t01"
        component: "SessionOrchestrator"
        usage: "Session management integration"
    
  implementation_steps:
    - step: "Create ADK-native checkpoint system"
      implementation_notes: |
        - ADK session snapshot models
        - Integration with SessionOrchestrator from r5-t01
        - Leverage ADK session state persistence
        
    - step: "Implement ADK-based recovery strategies"
      implementation_notes: |
        - State-based recovery using ADK session services
        - Event-based recovery using ADK event history
        - Integration with existing session backends
        
    - step: "Build auto-recovery using ADK patterns"
      implementation_notes: |
        - Use ADK's built-in error handling
        - Automatic recovery through SessionOrchestrator
        - Retry logic respecting ADK session lifecycle
        
    - step: "Add replay functionality with ADK events"
      implementation_notes: |
        - Session replay using ADK event stream
        - Point-in-time recovery from ADK session state
        - Debugging support through ADK session data
        
  validation:
    commands:
      - description: "Test ADK session recovery"
        command: "cd services/agent-engine && pytest tests/test_session_recovery.py -v"
        expected: "All tests pass with ADK integration"
        
    success_criteria:
      - "ADK session checkpointing working"
      - "Recovery strategies using SessionOrchestrator functional"
      - "Auto-recovery integrated with ADK error handling"
      - "Session replay using ADK event history working"
      - "All tests pass with proper ADK session management"
      
  dependencies:
    required_before:
      - task: "r5-t01"
        reason: "Need session orchestration"